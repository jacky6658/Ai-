<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AIJobçŸ­å½±éŸ³æ™ºèƒ½é«”</title>
    <style>
      :root { color-scheme: light; }
      body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background:#ffffff; color:#1a1a1a; }
      .container { max-width: 900px; margin: 0 auto; padding: 16px; }
      
      /* æ‰‹æ©Ÿç‰ˆå„ªåŒ– */
      @media (max-width: 768px) {
        .container { padding: 12px; }
        h1 { font-size: 16px; margin-bottom: 12px; }
        .chat { height: 50vh; padding: 12px; }
        .msg-bubble { max-width: 85%; padding: 10px 14px; font-size: 14px; }
        .settings-block { padding: 16px; margin-bottom: 12px; }
        .settings-block h3 { font-size: 14px; margin-bottom: 12px; }
        .settings-grid { grid-template-columns: 1fr; gap: 10px; margin-bottom: 12px; }
        .setting-item input, .setting-item select { padding: 10px 12px; font-size: 16px; }
        .apply-btn { padding: 12px 16px; font-size: 14px; }
        .controls { flex-direction: column; gap: 10px; }
        .controls .row { flex-direction: row !important; justify-content: space-between; }
        .controls .row button { flex: 1; margin: 0 4px; }
        textarea { min-height: 50px; font-size: 16px; }
        button { padding: 12px 16px; font-size: 14px; }
        .results-block { padding: 16px; }
        .results-block h3 { font-size: 14px; }
        .result-item h4 { font-size: 13px; }
        .result-item .content { padding: 10px; font-size: 14px; }
        .toast { top: 10px; right: 10px; left: 10px; max-width: none; font-size: 13px; }
      }
      h1 { font-size: 18px; font-weight: 600; color:#2563eb; margin: 0 0 16px; }
      .chat { border: 1px solid #e5e7eb; background: #f9fafb; border-radius: 12px; height: 60vh; overflow: auto; padding: 16px; }
      .msg { margin: 12px 0; line-height: 1.6; display: flex; }
      .msg.user { justify-content: flex-end; }
      .msg.assistant { justify-content: flex-start; }
      .msg-bubble { max-width: 70%; padding: 12px 16px; border-radius: 18px; white-space: pre-wrap; word-wrap: break-word; }
      .msg.user .msg-bubble { background: #3b82f6; color: #ffffff; border-bottom-right-radius: 4px; }
      .msg.assistant .msg-bubble { background: #f3f4f6; color: #374151; border-bottom-left-radius: 4px; }
      .msg-label { font-size: 12px; color: #6b7280; margin-bottom: 4px; }
      .msg.user .msg-label { text-align: right; }
      .msg.assistant .msg-label { text-align: left; }
      
      /* è¼‰å…¥å‹•ç•« */
      .loading { display: flex; align-items: center; gap: 8px; }
      .spinner { width: 16px; height: 16px; border: 2px solid #e5e7eb; border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .controls { display: flex; gap: 8px; margin-top: 12px; align-items:center; }
      textarea { flex: 1; min-height: 44px; max-height: 140px; resize: vertical; border-radius: 10px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding: 10px 12px; line-height: 1.4; -webkit-appearance: none; }
      button { padding: 10px 14px; border-radius: 10px; border:1px solid #d1d5db; background:#f9fafb; color:#374151; cursor:pointer; -webkit-appearance: none; }
      button:disabled { opacity: .6; cursor:not-allowed; }
      .row { display:flex; gap:8px; flex-direction:column; }
      .meta { display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap; }
      .meta input, .meta select { flex:1; min-width: 200px; border-radius: 8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding:8px 10px; }
      .small { font-size:12px; color:#6b7280; }
      .tag { display:inline-block; padding:4px 8px; border:1px solid #d1d5db; border-radius:999px; font-size:12px; color:#6b7280; background:#f3f4f6; }
      
      /* è¨­å®šå€å¡Šæ¨£å¼ */
      .settings-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-bottom:16px; }
      .settings-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; cursor:pointer; user-select:none; display:flex; align-items:center; gap:8px; }
      .settings-block h3:hover { color:#1d4ed8; }
      .settings-toggle { font-size:12px; transition:transform 0.2s ease; }
      .settings-content { transition:all 0.3s ease; overflow:hidden; }
      .settings-content.collapsed { max-height:0; margin:0; padding:0; }
      .settings-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:16px; }
      .setting-item { display:flex; flex-direction:column; gap:6px; }
      .setting-item label { font-size:12px; color:#6b7280; font-weight:500; }
      .setting-item input, .setting-item select { padding:8px 12px; border-radius:8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; -webkit-appearance: none; }
      .apply-btn { background:#3b82f6; border:1px solid #2563eb; color:#ffffff; padding:10px 20px; border-radius:8px; cursor:pointer; font-weight:500; }
      .apply-btn:hover { background:#2563eb; }
      .applied-tags { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
      
      /* çµæœå€å¡Šæ¨£å¼ */
      .results-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-top:16px; display:none; }
      .results-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; }
      .result-item { margin-bottom:16px; }
      .result-item h4 { margin:0 0 8px; color:#374151; font-size:14px; font-weight:500; }
      .result-item .content { background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:12px; color:#374151; white-space:pre-wrap; line-height:1.6; }
      
      /* å½ˆå‡ºæ¡†æ¨£å¼ */
      .toast { position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px; max-width: 300px; word-wrap: break-word; }
      .toast.show { animation: slideIn 0.3s ease-out; }
      .toast.hide { animation: slideOut 0.3s ease-in; }
      @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
      @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
      
      /* iOS Safari ç‰¹å®šå„ªåŒ– */
      @supports (-webkit-touch-callout: none) {
        .chat { -webkit-overflow-scrolling: touch; }
        textarea { -webkit-user-select: text; }
        input, select { -webkit-user-select: text; }
        .msg-bubble { -webkit-user-select: text; }
        .result-item .content { -webkit-user-select: text; }
      }
      
      /* é˜²æ­¢ iOS Safari ç¸®æ”¾ */
      input[type="text"], input[type="email"], input[type="password"], textarea, select { font-size: 16px; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AIJobçŸ­å½±éŸ³æ™ºèƒ½é«”</h1>

      <!-- è¨­å®šå€å¡Š -->
      <div class="settings-block">
        <h3 id="settingsToggle">ğŸ“‹ çŸ­å½±éŸ³è¨­å®š <span class="settings-toggle">â–¼</span></h3>
        <div class="settings-content" id="settingsContent">
          <div class="settings-grid">
          <div class="setting-item">
            <label>å¹³å°</label>
            <select id="platform">
              <option value="">é¸æ“‡å¹³å°</option>
              <option value="Reels">IG Reels</option>
              <option value="TikTok">TikTok</option>
              <option value="å°ç´…æ›¸">å°ç´…æ›¸</option>
            </select>
          </div>
          <div class="setting-item">
            <label>ä¸»é¡Œ</label>
            <input id="topic" placeholder="ä¾‹å¦‚ï¼šå¤å­£è®Šç™½æŒ‘æˆ° / ç¾ç™½ä¿é¤Š" />
          </div>
          <div class="setting-item">
            <label>è…³æœ¬ç§’æ•¸</label>
            <select id="duration">
              <option value="30">30ç§’</option>
              <option value="60">60ç§’</option>
              <option value="90">90ç§’</option>
            </select>
          </div>
          <div class="setting-item">
            <label>å¸³è™Ÿå®šä½</label>
            <input id="profile" placeholder="å¦‚ï¼šå¥åº·Ã—åŠ å¯†ï¼Œè¼•é¬†å¹½é»˜" />
          </div>
        </div>
        <button id="apply" class="apply-btn">å¥—ç”¨è¨­å®š</button>
          <div class="applied-tags">
            <span id="platformBadge" class="tag" style="display:none;"></span>
            <span id="topicBadge" class="tag" style="display:none;"></span>
            <span id="durationBadge" class="tag" style="display:none;"></span>
          </div>
        </div>
      </div>

      <div id="chat" class="chat"></div>

      <div class="controls">
        <textarea id="input" placeholder="è¼¸å…¥è¨Šæ¯â€¦ï¼ˆCtrl+Enter é€å‡ºã€Enter æ›è¡Œï¼‰"></textarea>
        <div class="row">
          <button id="send">é€å‡º</button>
          <button id="showResults">é¡¯ç¤ºçµæœå€å¡Š</button>
          <button id="testConnection">ğŸ”§ æ¸¬è©¦é€£ç·š</button>
        </div>
      </div>
      <div id="status" class="small"></div>
      
      <!-- çµæœå€å¡Š -->
      <div id="results" class="results-block">
        <h3>ğŸ“ çŸ­å½±éŸ³è…³æœ¬çµæœ</h3>
        <div class="result-item">
          <h4>ğŸ¯ ä¸»é¡Œ</h4>
          <div id="result-title" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ“œ è…³æœ¬å…§å®¹</h4>
          <div id="result-script" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ¬ ç•«é¢æ„Ÿ</h4>
          <div id="result-visual" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ“± æ–‡æ¡ˆ</h4>
          <div id="result-copy" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
      </div>
      
      <div class="small">2025 AIJobå­¸é™¢ç‰ˆæ¬Šæ‰€æœ‰</div>
    </div>

    <!-- å½ˆå‡ºæç¤ºæ¡† -->
    <div id="toast" class="toast" style="display: none;"></div>


    <script>
      const chatEl = document.getElementById('chat');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');
      const showResultsBtn = document.getElementById('showResults');
      const applyBtn = document.getElementById('apply');
      const platformEl = document.getElementById('platform');
      const topicEl = document.getElementById('topic');
      const durationEl = document.getElementById('duration');
      const profileEl = document.getElementById('profile');
      const platformBadge = document.getElementById('platformBadge');
      const topicBadge = document.getElementById('topicBadge');
      const durationBadge = document.getElementById('durationBadge');
      const statusEl = document.getElementById('status');
      const resultsEl = document.getElementById('results');
      const resultTitleEl = document.getElementById('result-title');
      const resultScriptEl = document.getElementById('result-script');
      const resultVisualEl = document.getElementById('result-visual');
      const resultCopyEl = document.getElementById('result-copy');
      const toastEl = document.getElementById('toast');
      const settingsToggleEl = document.getElementById('settingsToggle');
      const settingsContentEl = document.getElementById('settingsContent');
      const testConnectionBtn = document.getElementById('testConnection');

      let history = [];
      let lastMessage = '';
      let isSending = false;
      let lastSubmitAt = 0;
      let platformCurrent = '';
      let topicCurrent = '';
      let durationCurrent = '30';
      const styleInstruction = 'æ ¼å¼è¦æ±‚ï¼šåˆ†æ®µæ¸…æ¥šï¼ŒçŸ­å¥ï¼Œæ¯æ®µæ›è¡Œï¼Œé©åº¦åŠ å…¥è¡¨æƒ…ç¬¦è™Ÿï¼ˆå¦‚ï¼šâœ…âœ¨ğŸ”¥ğŸ“Œï¼‰ï¼Œé¿å…å£é ­ç¦ªã€‚çµ•å°ä¸è¦ä½¿ç”¨ ** æˆ–ä»»ä½• Markdown æ ¼å¼ç¬¦è™Ÿï¼Œæ‰€æœ‰å…§å®¹å¿…é ˆæ˜¯ç´”æ–‡å­—æ ¼å¼ã€‚';

      // å½ˆå‡ºæç¤ºæ¡†å‡½æ•¸
      function showToast(message, duration = 3000) {
        toastEl.textContent = message;
        toastEl.style.display = 'block';
        toastEl.className = 'toast show';
        
        setTimeout(() => {
          toastEl.className = 'toast hide';
          setTimeout(() => {
            toastEl.style.display = 'none';
          }, 300);
        }, duration);
      }

      // é¦–æ¬¡è¼‰å…¥é¡¯ç¤ºå¼•å°è¨Šæ¯
      document.addEventListener('DOMContentLoaded', () => {
        append('assistant', [
          'å—¨ï½å…ˆå¹«æˆ‘è¨­å®šï¼š',
          '1) é¸æ“‡å¹³å°ã€è¼¸å…¥ä¸»é¡Œèˆ‡å¸³è™Ÿå®šä½ï¼ŒæŒ‰ã€Œå¥—ç”¨ã€âœ…',
          '2) åœ¨ä¸‹æ–¹è¼¸å…¥ä½ æƒ³èŠçš„å…§å®¹ï¼ˆæˆ‘æœƒç”¨æ®µè½ï¼‹emoji å›è¦†ï¼‰âœ¨',
          '3) ä»»ä½•æ™‚å€™éƒ½å¯é‡æ–°ã€Œå¥—ç”¨ã€èª¿æ•´è¨­å®š ğŸ”„'
        ].join('\n'));
      });

      function append(role, text) {
        const div = document.createElement('div');
        div.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');
        
        const label = document.createElement('div');
        label.className = 'msg-label';
        label.textContent = role === 'user' ? 'ä½ ' : 'AI';
        
        const bubble = document.createElement('div');
        bubble.className = 'msg-bubble';
        
        // å¦‚æœæ˜¯ AI å›è¦†ï¼Œæ¸…ç† Markdown æ ¼å¼
        if (role === 'assistant') {
          const cleanText = cleanMarkdownFormat(text);
          bubble.innerHTML = cleanText;
        } else {
          bubble.textContent = text;
        }
        
        div.appendChild(label);
        div.appendChild(bubble);
        chatEl.appendChild(div);
        chatEl.scrollTop = chatEl.scrollHeight;
        return { container: div, bubble: bubble };
      }

      // æ¸…ç† Markdown æ ¼å¼ä¸¦è½‰æ›ç‚º HTML
      function cleanMarkdownFormat(text) {
        // è™•ç† Markdown æ¨™é¡Œæ ¼å¼
        text = text.replace(/^###\s*(.+)$/gm, '<strong>$1</strong>'); // ### æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        text = text.replace(/^##\s*(.+)$/gm, '<strong>$1</strong>');  // ## æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        text = text.replace(/^#\s*(.+)$/gm, '<strong>$1</strong>');   // # æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        
        // å°‡ **æ–‡å­—** è½‰æ›ç‚º <strong>æ–‡å­—</strong>
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // è™•ç†å…¶ä»–å¸¸è¦‹çš„ Markdown æ ¼å¼
        text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');           // *æ–œé«”* â†’ æ–œé«”
        text = text.replace(/`([^`]+)`/g, '<code>$1</code>');         // `ä»£ç¢¼` â†’ ä»£ç¢¼
        
        // ç§»é™¤å–®ç¨çš„ Markdown ç¬¦è™Ÿ
        text = text.replace(/\*\*/g, '');                             // ç§»é™¤å–®ç¨çš„ **
        text = text.replace(/^#{1,6}\s*/gm, '');                      // ç§»é™¤è¡Œé¦–çš„ # ç¬¦è™Ÿ
        
        return text;
      }

      function updateAssistantNode(nodeObj, text) {
        // æ¸…ç† Markdown æ ¼å¼
        const cleanText = cleanMarkdownFormat(text);
        
        if (nodeObj.bubble) {
          // ä½¿ç”¨ innerHTML ä¾†æ”¯æ´ HTML æ¨™ç±¤ï¼ˆå¦‚ <strong>ï¼‰
          nodeObj.bubble.innerHTML = cleanText;
        } else {
          nodeObj.innerHTML = cleanText;
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }

      function canSubmit() {
        if (isSending) return false;
        const now = Date.now();
        if (now - lastSubmitAt < 600) return false; // 600ms ç¯€æµ
        lastSubmitAt = now;
        return true;
      }

      async function send(message) {
        if (!message) return;
        if (!canSubmit()) return;
        lastMessage = message;
        const userNode = append('user', message);
        const assistantNode = append('assistant', '');

        // é¡¯ç¤º AI å›è¦†ä¸­çš„è¼‰å…¥ç‹€æ…‹
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.innerHTML = '<div class="spinner"></div><span>AIå›è¦†ä¸­...</span>';
        assistantNode.bubble.appendChild(loadingDiv);

        sendBtn.disabled = true;
        isSending = true;
        statusEl.textContent = 'æ­£åœ¨é€å‡ºâ€¦';

        try {
          // è‡ªå‹•åµæ¸¬ç’°å¢ƒï¼Œé–‹ç™¼æ™‚ä½¿ç”¨ localhostï¼Œéƒ¨ç½²æ™‚ä½¿ç”¨ç’°å¢ƒè®Šæ•¸æˆ–é è¨­å¾Œç«¯ç¶²åŸŸ
          const isDevelopment = window.location.hostname === 'localhost' || 
                                window.location.hostname === '127.0.0.1' ||
                                window.location.hostname === '0.0.0.0';
          
          // å¦‚æœæ˜¯é–‹ç™¼ç’°å¢ƒï¼Œä½¿ç”¨ localhost:8000ï¼›éƒ¨ç½²ç’°å¢ƒä½¿ç”¨æ­£ç¢ºçš„å¾Œç«¯ç¶²åŸŸ
          let endpoint;
          if (isDevelopment) {
            endpoint = 'http://127.0.0.1:8000/api/chat/stream';
          } else {
            // éƒ¨ç½²ç’°å¢ƒï¼šä½¿ç”¨æ‚¨æä¾›çš„æ­£ç¢ºå¾Œç«¯ç¶²åŸŸ
            endpoint = 'https://aivideobackend.zeabur.app/api/chat/stream';
          }
          // æ·»åŠ èª¿è©¦ä¿¡æ¯
          console.log('API ç«¯é»:', endpoint);
          console.log('ç•¶å‰ä½ç½®:', window.location.href);
          console.log('Hostname:', window.location.hostname);
          console.log('Port:', window.location.port);
          
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message,
              platform: (platformCurrent || platformEl?.value || '') || null,
              topic: (topicCurrent || topicEl?.value || '') || null,
              duration: (durationCurrent || durationEl?.value || '30'),
              style: styleInstruction,
              profile: (profileEl?.value || '') || null,
              history
            })
          });

          if (!res.ok) {
            const text = await res.text().catch(() => '');
            console.error('API è«‹æ±‚å¤±æ•—:', res.status, text);
            
            let errorMessage = `[è«‹æ±‚å¤±æ•— ${res.status}] `;
            try {
              const errorData = JSON.parse(text);
              if (errorData.error) {
                errorMessage += errorData.error;
                if (errorData.error.includes('GEMINI_API_KEY')) {
                  errorMessage += '\n\nğŸ’¡ è§£æ±ºæ–¹æ¡ˆï¼šè«‹åœ¨ Zeabur å¾Œç«¯æœå‹™çš„ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š GEMINI_API_KEY';
                }
              } else {
                errorMessage += text || 'ç„¡å›æ‡‰å…§å®¹';
              }
            } catch {
              errorMessage += text || 'ç„¡å›æ‡‰å…§å®¹';
            }
            
            updateAssistantNode(assistantNode, errorMessage);
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder('utf-8');
          let aiText = '';
          let buffer = '';

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const frame = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!frame.startsWith('data:')) continue;
              try {
                const jsonStr = frame.slice(5).trim();
                const evt = JSON.parse(jsonStr);
                if (evt.type === 'token') {
                  // ç§»é™¤è¼‰å…¥å‹•ç•«ï¼Œé–‹å§‹é¡¯ç¤º AI å›è¦†
                  const loadingDiv = assistantNode.bubble.querySelector('.loading');
                  if (loadingDiv) {
                    loadingDiv.remove();
                  }
                  aiText += evt.content;
                  updateAssistantNode(assistantNode, aiText);
                } else if (evt.type === 'end') {
                  history.push({ role: 'user', content: message });
                  history.push({ role: 'assistant', content: aiText });
                  
                  // æª¢æŸ¥æ˜¯å¦åŒ…å«è…³æœ¬çµæœï¼Œè‡ªå‹•é¡¯ç¤ºçµæœå€å¡Š
                  checkAndUpdateResults(aiText);
                }
              } catch (e) { /* ignore parse errors */ }
            }
          }
        } catch (e) {
          // ç§»é™¤è¼‰å…¥å‹•ç•«ï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
          const loadingDiv = assistantNode.bubble.querySelector('.loading');
          if (loadingDiv) {
            loadingDiv.remove();
          }
          console.error('è«‹æ±‚éŒ¯èª¤:', e);
          console.error('éŒ¯èª¤è©³æƒ…:', {
            message: e?.message,
            name: e?.name,
            stack: e?.stack,
            endpoint: endpoint,
            location: window.location.href
          });
          
          // æä¾›æ›´è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
          let errorMsg = `[éŒ¯èª¤] ${e?.message || e}`;
          if (e?.name === 'TypeError' && e?.message.includes('fetch')) {
            errorMsg = '[é€£ç·šéŒ¯èª¤] ç„¡æ³•é€£æ¥åˆ°ä¼ºæœå™¨ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦';
          } else if (e?.name === 'TypeError' && e?.message.includes('Failed to fetch')) {
            errorMsg = '[ç¶²è·¯éŒ¯èª¤] è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–é‡æ–°æ•´ç†é é¢';
          } else if (e?.message?.includes('CORS')) {
            errorMsg = '[è·¨åŸŸéŒ¯èª¤] è«‹å˜—è©¦é‡æ–°æ•´ç†é é¢';
          }
          
          // æ·»åŠ æ›´å¤šèª¿è©¦ä¿¡æ¯
          errorMsg += `\n\nèª¿è©¦ä¿¡æ¯ï¼š\nç«¯é»: ${endpoint}\nä½ç½®: ${window.location.href}`;
          updateAssistantNode(assistantNode, errorMsg);
        } finally {
          sendBtn.disabled = false;
          isSending = false;
          statusEl.textContent = '';
        }
      }

      sendBtn.addEventListener('click', () => {
        if (sendBtn.disabled || isSending) return;
        const text = inputEl.value.trim();
        if (!text) return;
        inputEl.value = '';
        send(text);
      });

      inputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
          if (sendBtn.disabled || isSending) return;
          e.preventDefault();
          const text = inputEl.value.trim();
          if (!text) return;
          inputEl.value = '';
          send(text);
        }
      });

      showResultsBtn.addEventListener('click', () => {
        resultsEl.style.display = resultsEl.style.display === 'none' ? 'block' : 'none';
        showResultsBtn.textContent = resultsEl.style.display === 'none' ? 'é¡¯ç¤ºçµæœå€å¡Š' : 'éš±è—çµæœå€å¡Š';
      });

      // è¨­å®šå€å¡Šæ‘ºç–Š/å±•é–‹åŠŸèƒ½
      settingsToggleEl.addEventListener('click', () => {
        const isCollapsed = settingsContentEl.classList.contains('collapsed');
        const toggleIcon = settingsToggleEl.querySelector('.settings-toggle');
        
        if (isCollapsed) {
          settingsContentEl.classList.remove('collapsed');
          toggleIcon.textContent = 'â–¼';
        } else {
          settingsContentEl.classList.add('collapsed');
          toggleIcon.textContent = 'â–¶';
        }
      });

      applyBtn.addEventListener('click', () => {
        platformCurrent = (platformEl?.value || '');
        topicCurrent = (topicEl?.value || '');
        durationCurrent = (durationEl?.value || '30');
        
        // æ›´æ–°å¾½ç« é¡¯ç¤º
        updateBadge(platformBadge, 'å¹³å°', platformCurrent);
        updateBadge(topicBadge, 'ä¸»é¡Œ', topicCurrent);
        updateBadge(durationBadge, 'ç§’æ•¸', durationCurrent + 'ç§’');

        // å¥—ç”¨å¾Œé¡¯ç¤ºå½ˆå‡ºæç¤ºæ¡†
        const message = `è¨­å®šå·²å¥—ç”¨ï¼\nå¹³å°ï¼š${platformCurrent || 'æœªé¸æ“‡'}\nä¸»é¡Œï¼š${topicCurrent || 'æœªè¼¸å…¥'}\nç§’æ•¸ï¼š${durationCurrent}ç§’`;
        showToast(message);
      });

      function updateBadge(badgeEl, label, value) {
        if (value) {
          badgeEl.style.display = 'inline-block';
          badgeEl.textContent = label + 'ï¼š' + value;
        } else {
          badgeEl.style.display = 'none';
          badgeEl.textContent = '';
        }
      }

      // æ¸¬è©¦é€£ç·šåŠŸèƒ½
      async function testConnection() {
        const testNode = append('assistant', 'ğŸ”§ æ­£åœ¨æ¸¬è©¦é€£ç·š...');
        
        try {
          // æ¸¬è©¦å¾Œç«¯æ ¹è·¯å¾‘
          const rootResponse = await fetch('https://aivideobackend.zeabur.app/');
          const rootText = await rootResponse.text();
          
          let testResult = `ğŸ” é€£ç·šæ¸¬è©¦çµæœï¼š\n\n`;
          testResult += `1ï¸âƒ£ å¾Œç«¯æ ¹è·¯å¾‘ï¼š${rootResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'} (ç‹€æ…‹ç¢¼: ${rootResponse.status})\n`;
          
          // æ¸¬è©¦å¥åº·æª¢æŸ¥
          try {
            const healthResponse = await fetch('https://aivideobackend.zeabur.app/api/health');
            const healthData = await healthResponse.json();
            
            testResult += `2ï¸âƒ£ å¥åº·æª¢æŸ¥ï¼š${healthResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'}\n`;
            testResult += `   - çŸ¥è­˜åº«ï¼š${healthData.kb_status}\n`;
            testResult += `   - Geminié…ç½®ï¼š${healthData.gemini_configured ? 'âœ… å·²é…ç½®' : 'âŒ æœªé…ç½®'}\n`;
            testResult += `   - Geminiæ¸¬è©¦ï¼š${healthData.gemini_test}\n`;
            testResult += `   - æ¨¡å‹ï¼š${healthData.model_name}\n`;
            
            if (!healthData.gemini_configured) {
              testResult += `\nâš ï¸ å•é¡Œï¼šGemini API Key æœªé…ç½®\n`;
              testResult += `ğŸ’¡ è§£æ±ºæ–¹æ¡ˆï¼šè«‹åœ¨ Zeabur å¾Œç«¯ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š GEMINI_API_KEY\n`;
            } else if (healthData.gemini_test !== 'working') {
              testResult += `\nâš ï¸ å•é¡Œï¼šGemini API é€£ç·šç•°å¸¸\n`;
              testResult += `ğŸ’¡ éŒ¯èª¤ï¼š${healthData.gemini_test}\n`;
            }
            
          } catch (healthError) {
            testResult += `2ï¸âƒ£ å¥åº·æª¢æŸ¥ï¼šâŒ ç„¡æ³•é€£ç·š (${healthError.message})\n`;
          }
          
          // æ¸¬è©¦èŠå¤©API
          try {
            const chatResponse = await fetch('https://aivideobackend.zeabur.app/api/chat/stream', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: 'test', platform: null, topic: null, duration: '30' })
            });
            
            testResult += `3ï¸âƒ£ èŠå¤©APIï¼š${chatResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'} (ç‹€æ…‹ç¢¼: ${chatResponse.status})\n`;
            
            if (!chatResponse.ok) {
              const errorText = await chatResponse.text();
              testResult += `   éŒ¯èª¤ï¼š${errorText}\n`;
            }
            
          } catch (chatError) {
            testResult += `3ï¸âƒ£ èŠå¤©APIï¼šâŒ ç„¡æ³•é€£ç·š (${chatError.message})\n`;
          }
          
          updateAssistantNode(testNode, testResult);
          
        } catch (error) {
          updateAssistantNode(testNode, `âŒ é€£ç·šæ¸¬è©¦å¤±æ•—ï¼š${error.message}`);
        }
      }

      // ç¶å®šæ¸¬è©¦é€£ç·šæŒ‰éˆ•
      testConnectionBtn.addEventListener('click', testConnection);

      function checkAndUpdateResults(aiText) {
        // æª¢æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…è¦çš„è…³æœ¬çµæ§‹æ¨™è¨˜
        const requiredMarkers = [
          { name: 'ä¸»é¡Œæ¨™é¡Œ', patterns: [/â—ä¸»é¡Œ\s*[ï¼š:]/, /^1\.\s*ä¸»é¡Œæ¨™é¡Œ\s*[ï¼š:]/m, /^###\s*ä¸»é¡Œæ¨™é¡Œ\s*[ï¼š:]/m, /\*\*ä¸»é¡Œæ¨™é¡Œ\*\*\s*[ï¼š:]/] },
          { name: 'è…³æœ¬å…§å®¹', patterns: [/^2\.\s*è…³æœ¬å…§å®¹\s*[ï¼š:]/m, /^###\s*è…³æœ¬å…§å®¹\s*[ï¼š:]/m, /\*\*è…³æœ¬å…§å®¹\*\*\s*[ï¼š:]/] },
          { name: 'ç•«é¢æ„Ÿ', patterns: [/^3\.\s*ç•«é¢æ„Ÿ\s*[ï¼ˆ(]é¡é ­[ã€,]éŸ³æ•ˆå»ºè­°[ï¼‰)]\s*[ï¼š:]/m, /^###\s*ç•«é¢æ„Ÿ\s*[ï¼š:]/m, /\*\*ç•«é¢æ„Ÿ\*\*\s*[ï¼š:]/] },
          { name: 'ç™¼ä½ˆæ–‡æ¡ˆ', patterns: [/^4\.\s*ç™¼ä½ˆæ–‡æ¡ˆ\s*[ï¼š:]/m, /^###\s*ç™¼ä½ˆæ–‡æ¡ˆ\s*[ï¼š:]/m, /\*\*ç™¼ä½ˆæ–‡æ¡ˆ\*\*\s*[ï¼š:]/] }
        ];
        
        // æª¢æŸ¥æ˜¯å¦åŒ…å«æ‰€æœ‰å¿…è¦çš„æ¨™è¨˜
        let hasAllRequiredMarkers = true;
        const foundMarkers = [];
        
        for (const marker of requiredMarkers) {
          const hasMarker = marker.patterns.some(pattern => pattern.test(aiText));
          foundMarkers.push({ name: marker.name, found: hasMarker });
          if (!hasMarker) {
            hasAllRequiredMarkers = false;
          }
        }
        
        // åªæœ‰ç•¶åŒ…å«æ‰€æœ‰å¿…è¦çš„æ¨™è¨˜æ™‚æ‰é¡¯ç¤ºçµæœå€å¡Š
        if (hasAllRequiredMarkers) {
          resultsEl.style.display = 'block';
          
          // å˜—è©¦è§£æä¸¦æ›´æ–°çµæœå€å¡Š
          try {
            // æå–ä¸»é¡Œæ¨™é¡Œ - å°æ‡‰åˆ° "ğŸ¯ ä¸»é¡Œ" æ¬„ä½
            let title = '';
            const titlePatterns = [
              /^â—ä¸»é¡Œ\s*[ï¼š:]\s*(.+?)(?:\n|$)/im,
              /^1\.\s*ä¸»é¡Œæ¨™é¡Œ\s*[ï¼š:]\s*(.+?)(?:\n|$)/im,
              /^###\s*ä¸»é¡Œæ¨™é¡Œ\s*[ï¼š:]\s*(.+?)(?:\n|$)/im,
              /^###\s*ä¸»é¡Œ\s*[ï¼š:]\s*(.+?)(?:\n|$)/im,
              /\*\*ä¸»é¡Œæ¨™é¡Œ\*\*[ï¼š:]\s*(.+?)(?:\n|$)/i,
              /\*\*ä¸»é¡Œ\*\*[ï¼š:]\s*(.+?)(?:\n|$)/i
            ];
            
            for (const pattern of titlePatterns) {
              const match = aiText.match(pattern);
              if (match && match[1] && match[1].trim().length > 3) {
                title = match[1].trim();
                break;
              }
            }
            
            if (title) {
              // æ¸…ç† Markdown æ ¼å¼ä¸¦é¡¯ç¤ºåˆ° "ğŸ¯ ä¸»é¡Œ" æ¬„ä½
              const cleanTitle = cleanMarkdownFormat(title);
              resultTitleEl.innerHTML = cleanTitle;
            }
            
            // æå–è…³æœ¬å…§å®¹ - å°æ‡‰åˆ° "ğŸ“œ è…³æœ¬å…§å®¹" æ¬„ä½
            let scriptContent = '';
            const scriptPatterns = [
              /^2\.\s*è…³æœ¬å…§å®¹\s*[ï¼š:]\s*([\s\S]+?)(?=(?:3\.|ç•«é¢æ„Ÿ|æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/im,
              /^###\s*è…³æœ¬å…§å®¹\s*[ï¼š:]\s*([\s\S]+?)(?=(?:###|ç•«é¢æ„Ÿ|æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/im,
              /\*\*è…³æœ¬å…§å®¹\*\*[ï¼š:]\s*([\s\S]+?)(?=(?:ç•«é¢æ„Ÿ|æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/i
            ];
            
            for (const pattern of scriptPatterns) {
              const match = aiText.match(pattern);
              if (match && match[1] && match[1].trim().length > 5) {
                scriptContent = match[1].trim();
                break;
              }
            }
            
            if (scriptContent) {
              // æ¸…ç† Markdown æ ¼å¼ä¸¦é¡¯ç¤ºåˆ° "ğŸ“œ è…³æœ¬å…§å®¹" æ¬„ä½
              const cleanScriptContent = cleanMarkdownFormat(scriptContent);
              resultScriptEl.innerHTML = cleanScriptContent;
            }
            
            // æå–ç•«é¢æ„Ÿ - å°æ‡‰åˆ° "ğŸ¬ ç•«é¢æ„Ÿ" æ¬„ä½
            const visualPatterns = [
              /^3\.\s*ç•«é¢æ„Ÿ\s*[ï¼ˆ(]é¡é ­[ã€,]éŸ³æ•ˆå»ºè­°[ï¼‰)]\s*[ï¼š:]\s*([\s\S]+?)(?=(?:4\.|æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/im,
              /^###\s*ç•«é¢æ„Ÿ\s*[ï¼š:]\s*([\s\S]+?)(?=(?:###|æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/im,
              /\*\*ç•«é¢æ„Ÿ\*\*[ï¼š:]\s*([\s\S]+?)(?=(?:æ–‡æ¡ˆ|ç™¼ä½ˆ|$))/i
            ];
            
            for (const pattern of visualPatterns) {
              const match = aiText.match(pattern);
              if (match && match[1] && match[1].trim().length > 5) {
                // æ¸…ç† Markdown æ ¼å¼ä¸¦é¡¯ç¤ºåˆ° "ğŸ¬ ç•«é¢æ„Ÿ" æ¬„ä½
                const cleanVisual = cleanMarkdownFormat(match[1].trim());
                resultVisualEl.innerHTML = cleanVisual;
                break;
              }
            }
            
            // æå–ç™¼ä½ˆæ–‡æ¡ˆ - å°æ‡‰åˆ° "ğŸ“± æ–‡æ¡ˆ" æ¬„ä½
            const copyPatterns = [
              /^4\.\s*ç™¼ä½ˆæ–‡æ¡ˆ\s*[ï¼š:]\s*([\s\S]+?)$/im,
              /^###\s*ç™¼ä½ˆæ–‡æ¡ˆ\s*[ï¼š:]\s*([\s\S]+?)$/im,
              /\*\*ç™¼ä½ˆæ–‡æ¡ˆ\*\*[ï¼š:]\s*([\s\S]+?)$/i
            ];
            
            for (const pattern of copyPatterns) {
              const match = aiText.match(pattern);
              if (match && match[1] && match[1].trim().length > 5) {
                // æ¸…ç† Markdown æ ¼å¼ä¸¦é¡¯ç¤ºåˆ° "ğŸ“± æ–‡æ¡ˆ" æ¬„ä½
                const cleanCopy = cleanMarkdownFormat(match[1].trim());
                resultCopyEl.innerHTML = cleanCopy;
                break;
              }
            }
            
          } catch (e) {
            console.log('è§£æçµæœæ™‚å‡ºéŒ¯:', e);
          }
        }
      }
    </script>
  </body>
  </html>


