<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AIJob短影音智能體</title>
    <style>
      :root { color-scheme: light; }
      body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background:#ffffff; color:#1a1a1a; }
      .container { max-width: 900px; margin: 0 auto; padding: 16px; }
      
      /* 手機版優化 */
      @media (max-width: 768px) {
        .container { padding: 12px; }
        h1 { font-size: 16px; margin-bottom: 12px; }
        .chat { height: 50vh; padding: 12px; }
        .msg-bubble { max-width: 85%; padding: 10px 14px; font-size: 14px; }
        .settings-block { padding: 16px; margin-bottom: 12px; }
        .settings-block h3 { font-size: 14px; margin-bottom: 12px; }
        .settings-grid { grid-template-columns: 1fr; gap: 10px; margin-bottom: 12px; }
        .setting-item input, .setting-item select { padding: 10px 12px; font-size: 16px; }
        .apply-btn { padding: 12px 16px; font-size: 14px; }
        .controls { flex-direction: column; gap: 10px; }
        .controls .row { flex-direction: row !important; justify-content: space-between; }
        .controls .row button { flex: 1; margin: 0 4px; }
        textarea { min-height: 50px; font-size: 16px; }
        button { padding: 12px 16px; font-size: 14px; }
        .results-block { padding: 16px; }
        .results-block h3 { font-size: 14px; }
        .result-item h4 { font-size: 13px; }
        .result-item .content { padding: 10px; font-size: 14px; }
        .toast { top: 10px; right: 10px; left: 10px; max-width: none; font-size: 13px; }
      }
      h1 { font-size: 18px; font-weight: 600; color:#2563eb; margin: 0 0 16px; }
      .chat { border: 1px solid #e5e7eb; background: #f9fafb; border-radius: 12px; height: 60vh; overflow: auto; padding: 16px; }
      .msg { margin: 12px 0; line-height: 1.6; display: flex; }
      .msg.user { justify-content: flex-end; }
      .msg.assistant { justify-content: flex-start; }
      .msg-bubble { max-width: 70%; padding: 12px 16px; border-radius: 18px; white-space: pre-wrap; word-wrap: break-word; }
      .msg.user .msg-bubble { background: #3b82f6; color: #ffffff; border-bottom-right-radius: 4px; }
      .msg.assistant .msg-bubble { background: #f3f4f6; color: #374151; border-bottom-left-radius: 4px; }
      .msg-label { font-size: 12px; color: #6b7280; margin-bottom: 4px; }
      .msg.user .msg-label { text-align: right; }
      .msg.assistant .msg-label { text-align: left; }
      
      /* 載入動畫 */
      .loading { display: flex; align-items: center; gap: 8px; }
      .spinner { width: 16px; height: 16px; border: 2px solid #e5e7eb; border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .controls { display: flex; gap: 8px; margin-top: 12px; align-items:center; }
      textarea { flex: 1; min-height: 44px; max-height: 140px; resize: vertical; border-radius: 10px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding: 10px 12px; line-height: 1.4; -webkit-appearance: none; }
      button { padding: 10px 14px; border-radius: 10px; border:1px solid #d1d5db; background:#f9fafb; color:#374151; cursor:pointer; -webkit-appearance: none; }
      button:disabled { opacity: .6; cursor:not-allowed; }
      .row { display:flex; gap:8px; flex-direction:column; }
      .meta { display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap; }
      .meta input, .meta select { flex:1; min-width: 200px; border-radius: 8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding:8px 10px; }
      .small { font-size:12px; color:#6b7280; }
      .tag { display:inline-block; padding:4px 8px; border:1px solid #d1d5db; border-radius:999px; font-size:12px; color:#6b7280; background:#f3f4f6; }
      
      /* 設定區塊樣式 */
      .settings-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-bottom:16px; }
      .settings-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; cursor:pointer; user-select:none; display:flex; align-items:center; gap:8px; }
      .settings-block h3:hover { color:#1d4ed8; }
      .settings-toggle { font-size:12px; transition:transform 0.2s ease; }
      .settings-content { transition:all 0.3s ease; overflow:hidden; }
      .settings-content.collapsed { max-height:0; margin:0; padding:0; }
      .settings-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:16px; }
      .setting-item { display:flex; flex-direction:column; gap:6px; }
      .setting-item label { font-size:12px; color:#6b7280; font-weight:500; }
      .setting-item input, .setting-item select { padding:8px 12px; border-radius:8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; -webkit-appearance: none; }
      .apply-btn { background:#3b82f6; border:1px solid #2563eb; color:#ffffff; padding:10px 20px; border-radius:8px; cursor:pointer; font-weight:500; }
      .apply-btn:hover { background:#2563eb; }
      .applied-tags { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
      
      /* 結果區塊樣式 */
      .results-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-top:16px; display:none; }
      .results-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; }
      .result-item { margin-bottom:16px; }
      .result-item h4 { margin:0 0 8px; color:#374151; font-size:14px; font-weight:500; }
      .result-item .content { background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:12px; color:#374151; white-space:pre-wrap; line-height:1.6; }
      
      /* 彈出框樣式 */
      .toast { position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px; max-width: 300px; word-wrap: break-word; }
      .toast.show { animation: slideIn 0.3s ease-out; }
      .toast.hide { animation: slideOut 0.3s ease-in; }
      @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
      @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
      
      /* iOS Safari 特定優化 */
      @supports (-webkit-touch-callout: none) {
        .chat { -webkit-overflow-scrolling: touch; }
        textarea { -webkit-user-select: text; }
        input, select { -webkit-user-select: text; }
        .msg-bubble { -webkit-user-select: text; }
        .result-item .content { -webkit-user-select: text; }
      }
      
      /* 防止 iOS Safari 縮放 */
      input[type="text"], input[type="email"], input[type="password"], textarea, select { font-size: 16px; }
      
      /* 快速按鈕樣式 */
      .quick-buttons { 
        display: flex; 
        gap: 8px; 
        margin-bottom: 12px; 
        flex-wrap: wrap;
        justify-content: center;
      }
      .quick-btn { 
        padding: 8px 16px; 
        border-radius: 20px; 
        border: 1px solid #3b82f6; 
        background: #ffffff; 
        color: #3b82f6; 
        cursor: pointer; 
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      .quick-btn:hover { 
        background: #3b82f6; 
        color: #ffffff; 
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
      }
      .quick-btn:active { 
        transform: translateY(0); 
        box-shadow: 0 1px 4px rgba(59, 130, 246, 0.2);
      }
      
      /* 手機版快速按鈕優化 */
      @media (max-width: 768px) {
        .quick-buttons { 
          gap: 6px; 
          margin-bottom: 10px;
        }
        .quick-btn { 
          padding: 6px 12px; 
          font-size: 13px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AIJob短影音智能體</h1>

      <!-- 設定區塊 -->
      <div class="settings-block">
        <h3 id="settingsToggle">📋 短影音設定 <span class="settings-toggle">▼</span></h3>
        <div class="settings-content" id="settingsContent">
          <div class="settings-grid">
          <div class="setting-item">
            <label>平台</label>
            <select id="platform">
              <option value="">選擇平台</option>
              <option value="Reels">IG Reels</option>
              <option value="TikTok">TikTok</option>
              <option value="小紅書">小紅書</option>
            </select>
          </div>
          <div class="setting-item">
            <label>主題</label>
            <input id="topic" placeholder="例如：夏季變白挑戰 / 美白保養" />
          </div>
          <div class="setting-item">
            <label>腳本秒數</label>
            <select id="duration">
              <option value="30">30秒</option>
              <option value="60">60秒</option>
              <option value="90">90秒</option>
            </select>
          </div>
          <div class="setting-item">
            <label>帳號定位</label>
            <input id="profile" placeholder="如：健康×加密，輕鬆幽默" />
          </div>
        </div>
        <button id="apply" class="apply-btn">套用設定</button>
          <div class="applied-tags">
            <span id="platformBadge" class="tag" style="display:none;"></span>
            <span id="topicBadge" class="tag" style="display:none;"></span>
            <span id="durationBadge" class="tag" style="display:none;"></span>
          </div>
        </div>
      </div>

      <div id="chat" class="chat"></div>

      <!-- 快速按鈕區域 -->
      <div class="quick-buttons">
        <button class="quick-btn" data-text="請幫我生成一個完整的短影音腳本，包含主題標題、腳本內容、畫面感和發佈文案">生成腳本</button>
        <button class="quick-btn" data-text="請幫我推薦一些熱門的短影音選題和話題方向">腳本選題</button>
        <button class="quick-btn" data-text="請幫我分析並建議適合的帳號定位策略，包括內容方向和目標受眾">帳號定位</button>
      </div>

      <div class="controls">
        <textarea id="input" placeholder="輸入訊息…（Ctrl+Enter 送出、Enter 換行）"></textarea>
        <div class="row">
          <button id="send">送出</button>
          <button id="showResults">顯示結果區塊</button>
          <button id="testConnection">🔧 測試連線</button>
        </div>
      </div>
      <div id="status" class="small"></div>
      
      <!-- 結果區塊 -->
      <div id="results" class="results-block">
        <h3>📝 短影音腳本結果</h3>
        <div class="result-item">
          <h4>🎯 主題</h4>
          <div id="result-title" class="content">尚未生成</div>
        </div>
        <div class="result-item">
          <h4>📜 腳本內容</h4>
          <div id="result-script" class="content">尚未生成</div>
        </div>
        <div class="result-item">
          <h4>🎬 畫面感</h4>
          <div id="result-visual" class="content">尚未生成</div>
        </div>
        <div class="result-item">
          <h4>📱 文案</h4>
          <div id="result-copy" class="content">尚未生成</div>
        </div>
      </div>
      
      <div class="small">2025 AIJob學院版權所有</div>
    </div>

    <!-- 彈出提示框 -->
    <div id="toast" class="toast" style="display: none;"></div>


    <script>
      const chatEl = document.getElementById('chat');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');
      const showResultsBtn = document.getElementById('showResults');
      const applyBtn = document.getElementById('apply');
      const platformEl = document.getElementById('platform');
      const topicEl = document.getElementById('topic');
      const durationEl = document.getElementById('duration');
      const profileEl = document.getElementById('profile');
      const platformBadge = document.getElementById('platformBadge');
      const topicBadge = document.getElementById('topicBadge');
      const durationBadge = document.getElementById('durationBadge');
      const statusEl = document.getElementById('status');
      const resultsEl = document.getElementById('results');
      const resultTitleEl = document.getElementById('result-title');
      const resultScriptEl = document.getElementById('result-script');
      const resultVisualEl = document.getElementById('result-visual');
      const resultCopyEl = document.getElementById('result-copy');
      const toastEl = document.getElementById('toast');
      const settingsToggleEl = document.getElementById('settingsToggle');
      const settingsContentEl = document.getElementById('settingsContent');
      const testConnectionBtn = document.getElementById('testConnection');

      let history = [];
      let lastMessage = '';
      let isSending = false;
      let lastSubmitAt = 0;
      let platformCurrent = '';
      let topicCurrent = '';
      let durationCurrent = '30';
      const styleInstruction = '格式要求：分段清楚，短句，每段換行，適度加入表情符號（如：✅✨🔥📌），避免口頭禪。絕對不要使用 ** 或任何 Markdown 格式符號，所有內容必須是純文字格式。';

      // 彈出提示框函數
      function showToast(message, duration = 3000) {
        toastEl.textContent = message;
        toastEl.style.display = 'block';
        toastEl.className = 'toast show';
        
        setTimeout(() => {
          toastEl.className = 'toast hide';
          setTimeout(() => {
            toastEl.style.display = 'none';
          }, 300);
        }, duration);
      }

      // 首次載入顯示引導訊息
      document.addEventListener('DOMContentLoaded', () => {
        append('assistant', [
          '嗨～先幫我設定：',
          '1) 選擇平台、輸入主題與帳號定位，按「套用」✅',
          '2) 在下方輸入你想聊的內容（我會用段落＋emoji 回覆）✨',
          '3) 任何時候都可重新「套用」調整設定 🔄'
        ].join('\n'));
      });

      function append(role, text) {
        const div = document.createElement('div');
        div.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');
        
        const label = document.createElement('div');
        label.className = 'msg-label';
        label.textContent = role === 'user' ? '你' : 'AI';
        
        const bubble = document.createElement('div');
        bubble.className = 'msg-bubble';
        
        // 如果是 AI 回覆，清理 Markdown 格式
        if (role === 'assistant') {
          const cleanText = cleanMarkdownFormat(text);
          bubble.innerHTML = cleanText;
        } else {
          bubble.textContent = text;
        }
        
        div.appendChild(label);
        div.appendChild(bubble);
        chatEl.appendChild(div);
        chatEl.scrollTop = chatEl.scrollHeight;
        return { container: div, bubble: bubble };
      }

      // 清理 Markdown 格式並轉換為 HTML
      function cleanMarkdownFormat(text) {
        // 處理 Markdown 標題格式
        text = text.replace(/^###\s*(.+)$/gm, '<strong>$1</strong>'); // ### 標題 → **標題**
        text = text.replace(/^##\s*(.+)$/gm, '<strong>$1</strong>');  // ## 標題 → **標題**
        text = text.replace(/^#\s*(.+)$/gm, '<strong>$1</strong>');   // # 標題 → **標題**
        
        // 將 **文字** 轉換為 <strong>文字</strong>
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // 處理其他常見的 Markdown 格式
        text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');           // *斜體* → 斜體
        text = text.replace(/`([^`]+)`/g, '<code>$1</code>');         // `代碼` → 代碼
        
        // 移除單獨的 Markdown 符號
        text = text.replace(/\*\*/g, '');                             // 移除單獨的 **
        text = text.replace(/^#{1,6}\s*/gm, '');                      // 移除行首的 # 符號
        
        return text;
      }

      function updateAssistantNode(nodeObj, text) {
        // 清理 Markdown 格式
        const cleanText = cleanMarkdownFormat(text);
        
        if (nodeObj.bubble) {
          // 使用 innerHTML 來支援 HTML 標籤（如 <strong>）
          nodeObj.bubble.innerHTML = cleanText;
        } else {
          nodeObj.innerHTML = cleanText;
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }

      function canSubmit() {
        if (isSending) return false;
        const now = Date.now();
        if (now - lastSubmitAt < 600) return false; // 600ms 節流
        lastSubmitAt = now;
        return true;
      }

      async function send(message) {
        if (!message) return;
        if (!canSubmit()) return;
        lastMessage = message;
        const userNode = append('user', message);
        const assistantNode = append('assistant', '');

        // 顯示 AI 回覆中的載入狀態
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.innerHTML = '<div class="spinner"></div><span>AI回覆中...</span>';
        assistantNode.bubble.appendChild(loadingDiv);

        sendBtn.disabled = true;
        isSending = true;
        statusEl.textContent = '正在送出…';

        try {
          // 自動偵測環境，開發時使用 localhost，部署時使用環境變數或預設後端網域
          const isDevelopment = window.location.hostname === 'localhost' || 
                                window.location.hostname === '127.0.0.1' ||
                                window.location.hostname === '0.0.0.0';
          
          // 如果是開發環境，使用 localhost:8000；部署環境使用正確的後端網域
          let endpoint;
          if (isDevelopment) {
            endpoint = 'http://127.0.0.1:8000/api/chat/stream';
          } else {
            // 部署環境：使用您提供的正確後端網域
            endpoint = 'https://aivideobackend.zeabur.app/api/chat/stream';
          }
          // 添加調試信息
          console.log('API 端點:', endpoint);
          console.log('當前位置:', window.location.href);
          console.log('Hostname:', window.location.hostname);
          console.log('Port:', window.location.port);
          
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message,
              platform: (platformCurrent || platformEl?.value || '') || null,
              topic: (topicCurrent || topicEl?.value || '') || null,
              duration: (durationCurrent || durationEl?.value || '30'),
              style: styleInstruction,
              profile: (profileEl?.value || '') || null,
              history
            })
          });

          if (!res.ok) {
            const text = await res.text().catch(() => '');
            console.error('API 請求失敗:', res.status, text);
            
            let errorMessage = `[請求失敗 ${res.status}] `;
            try {
              const errorData = JSON.parse(text);
              if (errorData.error) {
                errorMessage += errorData.error;
                if (errorData.error.includes('GEMINI_API_KEY')) {
                  errorMessage += '\n\n💡 解決方案：請在 Zeabur 後端服務的環境變數中設定 GEMINI_API_KEY';
                }
              } else {
                errorMessage += text || '無回應內容';
              }
            } catch {
              errorMessage += text || '無回應內容';
            }
            
            updateAssistantNode(assistantNode, errorMessage);
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder('utf-8');
          let aiText = '';
          let buffer = '';

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const frame = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!frame.startsWith('data:')) continue;
              try {
                const jsonStr = frame.slice(5).trim();
                const evt = JSON.parse(jsonStr);
                if (evt.type === 'token') {
                  // 移除載入動畫，開始顯示 AI 回覆
                  const loadingDiv = assistantNode.bubble.querySelector('.loading');
                  if (loadingDiv) {
                    loadingDiv.remove();
                  }
                  aiText += evt.content;
                  updateAssistantNode(assistantNode, aiText);
                } else if (evt.type === 'end') {
                  history.push({ role: 'user', content: message });
                  history.push({ role: 'assistant', content: aiText });
                  
                  // 檢查是否包含腳本結果，自動顯示結果區塊
                  checkAndUpdateResults(aiText);
                }
              } catch (e) { /* ignore parse errors */ }
            }
          }
        } catch (e) {
          // 移除載入動畫，顯示錯誤訊息
          const loadingDiv = assistantNode.bubble.querySelector('.loading');
          if (loadingDiv) {
            loadingDiv.remove();
          }
          console.error('請求錯誤:', e);
          console.error('錯誤詳情:', {
            message: e?.message,
            name: e?.name,
            stack: e?.stack,
            endpoint: endpoint,
            location: window.location.href
          });
          
          // 提供更詳細的錯誤訊息
          let errorMsg = `[錯誤] ${e?.message || e}`;
          if (e?.name === 'TypeError' && e?.message.includes('fetch')) {
            errorMsg = '[連線錯誤] 無法連接到伺服器，請檢查網路連線或稍後再試';
          } else if (e?.name === 'TypeError' && e?.message.includes('Failed to fetch')) {
            errorMsg = '[網路錯誤] 請檢查網路連線或重新整理頁面';
          } else if (e?.message?.includes('CORS')) {
            errorMsg = '[跨域錯誤] 請嘗試重新整理頁面';
          }
          
          // 添加更多調試信息
          errorMsg += `\n\n調試信息：\n端點: ${endpoint}\n位置: ${window.location.href}`;
          updateAssistantNode(assistantNode, errorMsg);
        } finally {
          sendBtn.disabled = false;
          isSending = false;
          statusEl.textContent = '';
        }
      }

      sendBtn.addEventListener('click', () => {
        if (sendBtn.disabled || isSending) return;
        const text = inputEl.value.trim();
        if (!text) return;
        inputEl.value = '';
        send(text);
      });

      inputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
          if (sendBtn.disabled || isSending) return;
          e.preventDefault();
          const text = inputEl.value.trim();
          if (!text) return;
          inputEl.value = '';
          send(text);
        }
      });

      showResultsBtn.addEventListener('click', () => {
        resultsEl.style.display = resultsEl.style.display === 'none' ? 'block' : 'none';
        showResultsBtn.textContent = resultsEl.style.display === 'none' ? '顯示結果區塊' : '隱藏結果區塊';
      });

      // 設定區塊摺疊/展開功能
      settingsToggleEl.addEventListener('click', () => {
        const isCollapsed = settingsContentEl.classList.contains('collapsed');
        const toggleIcon = settingsToggleEl.querySelector('.settings-toggle');
        
        if (isCollapsed) {
          settingsContentEl.classList.remove('collapsed');
          toggleIcon.textContent = '▼';
        } else {
          settingsContentEl.classList.add('collapsed');
          toggleIcon.textContent = '▶';
        }
      });

      applyBtn.addEventListener('click', () => {
        platformCurrent = (platformEl?.value || '');
        topicCurrent = (topicEl?.value || '');
        durationCurrent = (durationEl?.value || '30');
        
        // 更新徽章顯示
        updateBadge(platformBadge, '平台', platformCurrent);
        updateBadge(topicBadge, '主題', topicCurrent);
        updateBadge(durationBadge, '秒數', durationCurrent + '秒');

        // 套用後顯示彈出提示框
        const message = `設定已套用！\n平台：${platformCurrent || '未選擇'}\n主題：${topicCurrent || '未輸入'}\n秒數：${durationCurrent}秒`;
        showToast(message);
      });

      function updateBadge(badgeEl, label, value) {
        if (value) {
          badgeEl.style.display = 'inline-block';
          badgeEl.textContent = label + '：' + value;
        } else {
          badgeEl.style.display = 'none';
          badgeEl.textContent = '';
        }
      }

      // 測試連線功能
      async function testConnection() {
        const testNode = append('assistant', '🔧 正在測試連線...');
        
        try {
          // 測試後端根路徑
          const rootResponse = await fetch('https://aivideobackend.zeabur.app/');
          const rootText = await rootResponse.text();
          
          let testResult = `🔍 連線測試結果：\n\n`;
          testResult += `1️⃣ 後端根路徑：${rootResponse.ok ? '✅ 正常' : '❌ 異常'} (狀態碼: ${rootResponse.status})\n`;
          
          // 測試健康檢查
          try {
            const healthResponse = await fetch('https://aivideobackend.zeabur.app/api/health');
            const healthData = await healthResponse.json();
            
            testResult += `2️⃣ 健康檢查：${healthResponse.ok ? '✅ 正常' : '❌ 異常'}\n`;
            testResult += `   - 知識庫：${healthData.kb_status}\n`;
            testResult += `   - Gemini配置：${healthData.gemini_configured ? '✅ 已配置' : '❌ 未配置'}\n`;
            testResult += `   - Gemini測試：${healthData.gemini_test}\n`;
            testResult += `   - 模型：${healthData.model_name}\n`;
            
            if (!healthData.gemini_configured) {
              testResult += `\n⚠️ 問題：Gemini API Key 未配置\n`;
              testResult += `💡 解決方案：請在 Zeabur 後端環境變數中設定 GEMINI_API_KEY\n`;
            } else if (healthData.gemini_test !== 'working') {
              testResult += `\n⚠️ 問題：Gemini API 連線異常\n`;
              testResult += `💡 錯誤：${healthData.gemini_test}\n`;
            }
            
          } catch (healthError) {
            testResult += `2️⃣ 健康檢查：❌ 無法連線 (${healthError.message})\n`;
          }
          
          // 測試聊天API
          try {
            const chatResponse = await fetch('https://aivideobackend.zeabur.app/api/chat/stream', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: 'test', platform: null, topic: null, duration: '30' })
            });
            
            testResult += `3️⃣ 聊天API：${chatResponse.ok ? '✅ 正常' : '❌ 異常'} (狀態碼: ${chatResponse.status})\n`;
            
            if (!chatResponse.ok) {
              const errorText = await chatResponse.text();
              testResult += `   錯誤：${errorText}\n`;
            }
            
          } catch (chatError) {
            testResult += `3️⃣ 聊天API：❌ 無法連線 (${chatError.message})\n`;
          }
          
          updateAssistantNode(testNode, testResult);
          
        } catch (error) {
          updateAssistantNode(testNode, `❌ 連線測試失敗：${error.message}`);
        }
      }

      // 綁定測試連線按鈕
      testConnectionBtn.addEventListener('click', testConnection);

      // 添加全局測試函數（用於調試）
      window.testDOM = function() {
        console.log('=== DOM元素測試 ===');
        console.log('resultTitleEl:', resultTitleEl);
        console.log('resultScriptEl:', resultScriptEl);
        console.log('resultVisualEl:', resultVisualEl);
        console.log('resultCopyEl:', resultCopyEl);
        
        if (resultTitleEl) {
          resultTitleEl.innerHTML = '測試標題';
          console.log('測試標題設置成功');
        }
        if (resultScriptEl) {
          resultScriptEl.innerHTML = '測試腳本內容';
          console.log('測試腳本內容設置成功');
        }
        if (resultVisualEl) {
          resultVisualEl.innerHTML = '測試畫面感';
          console.log('測試畫面感設置成功');
        }
        if (resultCopyEl) {
          resultCopyEl.innerHTML = '測試發佈文案';
          console.log('測試發佈文案設置成功');
        }
      };

      // 快速按鈕功能
      document.querySelectorAll('.quick-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const text = btn.getAttribute('data-text');
          if (text) {
            inputEl.value = text;
            inputEl.focus();
            
            // 添加視覺反饋
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => {
              btn.style.transform = '';
            }, 150);
            
            // 可選：自動發送（如果需要可以取消註釋）
            // if (text.trim()) {
            //   send(text);
            // }
          }
        });
      });

      function checkAndUpdateResults(aiText) {
        console.log('=== 開始解析AI回應 ===');
        console.log('AI回應長度:', aiText.length);
        console.log('AI回應前300字符:', aiText.substring(0, 300));
        
        // 更精確的腳本內容檢測
        const isScriptContent = detectScriptContent(aiText);
        
        console.log('是否為腳本內容:', isScriptContent);
        
        if (isScriptContent) {
          // 顯示結果區塊
          resultsEl.style.display = 'block';
          console.log('結果區塊已顯示，開始解析內容...');
          
          // 確保DOM元素存在
          if (!resultTitleEl || !resultScriptEl || !resultVisualEl || !resultCopyEl) {
            console.error('DOM元素不存在:', {
              resultTitleEl: !!resultTitleEl,
              resultScriptEl: !!resultScriptEl,
              resultVisualEl: !!resultVisualEl,
              resultCopyEl: !!resultCopyEl
            });
            return;
          }
          
          try {
            // 使用更靈活的解析方法
            const sections = parseAIContent(aiText);
            
            // 更新DOM元素
            if (sections.title) {
              resultTitleEl.innerHTML = sections.title;
              console.log('✅ 主題標題已設置:', sections.title);
            }
            
            if (sections.script) {
              resultScriptEl.innerHTML = sections.script;
              console.log('✅ 腳本內容已設置:', sections.script.substring(0, 100) + '...');
            }
            
            if (sections.visual) {
              resultVisualEl.innerHTML = sections.visual;
              console.log('✅ 畫面感已設置:', sections.visual.substring(0, 100) + '...');
            }
            
            if (sections.copy) {
              resultCopyEl.innerHTML = sections.copy;
              console.log('✅ 發佈文案已設置:', sections.copy.substring(0, 100) + '...');
            }
            
            // 延遲檢查內容是否正確設置
            setTimeout(() => {
              console.log('=== 延遲檢查DOM內容 ===');
              console.log('主題標題:', resultTitleEl.innerHTML);
              console.log('腳本內容:', resultScriptEl.innerHTML.substring(0, 100) + '...');
              console.log('畫面感:', resultVisualEl.innerHTML.substring(0, 100) + '...');
              console.log('發佈文案:', resultCopyEl.innerHTML.substring(0, 100) + '...');
            }, 500);
            
          } catch (e) {
            console.error('解析結果時出錯:', e);
          }
        } else {
          console.log('未檢測到腳本內容，不顯示結果區塊');
        }
      }
      
      // 新增：精確的腳本內容檢測函數
      function detectScriptContent(aiText) {
        console.log('=== 開始腳本內容檢測 ===');
        console.log('檢測文本長度:', aiText.length);
        console.log('檢測文本前200字符:', aiText.substring(0, 200));
        
        // 1. 檢查是否包含腳本相關的結構標記（更靈活的檢測）
        const structureMarkers = [
          /主題標題[：:]/i,
          /腳本內容[：:]/i,
          /畫面感[：:]/i,
          /發佈文案[：:]/i,
          /\d+\.\s*主題標題/i,
          /\d+\.\s*腳本內容/i,
          /\d+\.\s*畫面感/i,
          /\d+\.\s*發佈文案/i,
          /Hook\s*\(\d+-\d+秒\)/i,
          /Value\s*\d+\s*\(\d+-\d+秒\)/i,
          /CTA\s*\(\d+-\d+秒\)/i
        ];
        
        const hasStructureMarkers = structureMarkers.some(pattern => pattern.test(aiText));
        console.log('是否包含腳本結構標記:', hasStructureMarkers);
        
        // 2. 檢查是否包含短影音腳本的關鍵元素
        const scriptElements = [
          /Hook\s*\(\d+-\d+秒\)/i,
          /Value\s*\d+\s*\(\d+-\d+秒\)/i,
          /CTA\s*\(\d+-\d+秒\)/i,
          /畫面感[：:]/i,
          /發佈文案[：:]/i,
          /\d+\.\s*畫面感/i,
          /\d+\.\s*發佈文案/i,
          /鏡頭[：:]/i,
          /音效[：:]/i,
          /字幕[：:]/i,
          /台詞[：:]/i
        ];
        
        const scriptElementCount = scriptElements.filter(pattern => pattern.test(aiText)).length;
        console.log('腳本元素數量:', scriptElementCount);
        
        // 如果沒有腳本結構標記且腳本元素少於3個，直接返回 false
        if (!hasStructureMarkers && scriptElementCount < 3) {
          console.log('❌ 未包含足夠的腳本結構標記，不顯示結果區塊');
          return false;
        }
        
        // 2. 檢查是否包含腳本相關的關鍵詞組合
        const scriptKeywords = ['主題標題', '腳本內容', '畫面感', '發佈文案', 'Hook', 'Value', 'CTA'];
        const keywordCount = scriptKeywords.filter(keyword => aiText.includes(keyword)).length;
        console.log('腳本關鍵詞數量:', keywordCount);
        
        // 3. 檢查是否包含短影音相關的內容指示詞
        const videoIndicators = [
          '短影音腳本',
          '短影音腳本結果',
          '生成腳本',
          '腳本生成',
          'Reels',
          'TikTok',
          '小紅書',
          '秒腳本',
          '影音內容',
          '短影音',
          '腳本'
        ];
        const hasVideoIndicators = videoIndicators.some(indicator => aiText.includes(indicator));
        console.log('是否包含短影音指示詞:', hasVideoIndicators);
        
        // 4. 檢查文本長度（腳本內容通常較長）
        const isLongEnough = aiText.length > 300; // 提高長度要求
        console.log('文本是否足夠長:', isLongEnough);
        
        // 5. 檢查是否包含多個段落（腳本通常有多個部分）
        const paragraphCount = aiText.split('\n\n').filter(p => p.trim().length > 0).length;
        const hasMultipleParagraphs = paragraphCount >= 4; // 提高段落要求
        console.log('段落數量:', paragraphCount, '是否多段落:', hasMultipleParagraphs);
        
        // 6. 排除明顯的非腳本內容
        const nonScriptIndicators = [
          '你好',
          '謝謝',
          '不客氣',
          '請問',
          '不好意思',
          '抱歉',
          '我來幫你',
          '讓我為你',
          '很高興為您',
          '歡迎',
          '再見',
          '拜拜',
          '有什麼可以幫你',
          '需要什麼幫助',
          '請告訴我',
          '請輸入',
          '請選擇',
          '請點擊',
          '請查看',
          '請注意',
          '提醒',
          '建議',
          '推薦',
          '介紹',
          '說明',
          '解釋',
          '回答',
          '回覆',
          '回應'
        ];
        const hasNonScriptIndicators = nonScriptIndicators.some(indicator => 
          aiText.toLowerCase().includes(indicator.toLowerCase())
        );
        console.log('是否包含非腳本指示詞:', hasNonScriptIndicators);
        
        // 7. 檢查是否包含完整的腳本結構（至少包含3個區塊）
        const structureCount = requiredStructureMarkers.filter(pattern => pattern.test(aiText)).length;
        const hasCompleteStructure = structureCount >= 3;
        console.log('結構區塊數量:', structureCount, '是否完整結構:', hasCompleteStructure);
        
        // 8. 檢查是否包含時間標記（腳本通常有時間標記）
        const timeMarkers = [
          /\d+[-\s]*\d*\s*秒/i,
          /\d+[-\s]*\d*\s*分鐘/i,
          /0-\d+\s*秒/i,
          /\d+-\d+\s*秒/i
        ];
        const hasTimeMarkers = timeMarkers.some(pattern => pattern.test(aiText));
        console.log('是否包含時間標記:', hasTimeMarkers);
        
        // 綜合判斷
        const score = {
          structureMarkers: hasStructureMarkers ? 3 : 0,
          scriptElements: Math.min(scriptElementCount, 4), // 腳本元素數量
          keywordCount: Math.min(keywordCount, 3),
          videoIndicators: hasVideoIndicators ? 2 : 0,
          length: isLongEnough ? 1 : 0,
          paragraphs: hasMultipleParagraphs ? 1 : 0,
          completeStructure: hasCompleteStructure ? 2 : 0,
          timeMarkers: hasTimeMarkers ? 1 : 0,
          nonScript: hasNonScriptIndicators ? -5 : 0 // 高懲罰
        };
        
        const totalScore = Object.values(score).reduce((sum, val) => sum + val, 0);
        
        console.log('腳本檢測評分:', score);
        console.log('總分:', totalScore);
        
        // 更靈活的判斷條件
        const isScriptContent = totalScore >= 4 && !hasNonScriptIndicators && (hasStructureMarkers || scriptElementCount >= 3);
        
        console.log('是否為腳本內容:', isScriptContent);
        console.log('=== 腳本內容檢測結束 ===');
        
        return isScriptContent;
      }
      
      // 新增：更精確的AI內容解析函數
      function parseAIContent(aiText) {
        const sections = {
          title: '',
          script: '',
          visual: '',
          copy: ''
        };
        
        console.log('開始解析AI內容...');
        console.log('原始AI文本:', aiText);
        
        // 使用正則表達式精確提取每個區塊的內容
        try {
          // 1. 提取主題標題
          const titlePatterns = [
            /主題標題[：:]\s*([^\n]+)/i,
            /主題[：:]\s*([^\n]+)/i,
            /標題[：:]\s*([^\n]+)/i,
            /\d+\.\s*主題標題[：:]\s*([^\n]+)/i,
            /\d+\.\s*主題[：:]\s*([^\n]+)/i,
            /\d+\.\s*標題[：:]\s*([^\n]+)/i
          ];
          
          for (const pattern of titlePatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.title = cleanMarkdownFormat(match[1].trim());
              console.log('找到主題標題:', sections.title);
              break;
            }
          }
          
          // 如果沒有找到明確的主題標題，嘗試提取第一行作為標題
          if (!sections.title) {
            const lines = aiText.split('\n').filter(line => line.trim().length > 0);
            const firstLine = lines[0];
            if (firstLine && !firstLine.match(/^(Hook|Value|CTA|畫面感|發佈文案)/i)) {
              sections.title = cleanMarkdownFormat(firstLine.trim());
              console.log('使用第一行作為主題標題:', sections.title);
            }
          }
          
          // 2. 提取腳本內容
          const scriptPatterns = [
            /腳本內容[：:]\s*([\s\S]*?)(?=\n\s*(?:畫面感|發佈文案|$))/i,
            /腳本[：:]\s*([\s\S]*?)(?=\n\s*(?:畫面感|發佈文案|$))/i,
            /\d+\.\s*腳本內容[：:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*畫面感|\d+\.\s*發佈文案|$))/i,
            /\d+\.\s*腳本[：:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*畫面感|\d+\.\s*發佈文案|$))/i
          ];
          
          for (const pattern of scriptPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.script = cleanMarkdownFormat(match[1].trim());
              console.log('找到腳本內容:', sections.script.substring(0, 100) + '...');
              break;
            }
          }
          
          // 如果沒有找到明確的腳本內容標記，嘗試提取 Hook、Value、CTA 部分
          if (!sections.script) {
            const hookPattern = /Hook\s*\(\d+-\d+秒\)[\s\S]*?(?=Value|畫面感|發佈文案|$)/i;
            const valuePattern = /Value\s*\d+\s*\(\d+-\d+秒\)[\s\S]*?(?=Value|CTA|畫面感|發佈文案|$)/i;
            const ctaPattern = /CTA\s*\(\d+-\d+秒\)[\s\S]*?(?=畫面感|發佈文案|$)/i;
            
            const hookMatch = aiText.match(hookPattern);
            const valueMatches = aiText.match(new RegExp(valuePattern.source, 'gi'));
            const ctaMatch = aiText.match(ctaPattern);
            
            let scriptContent = '';
            if (hookMatch) scriptContent += hookMatch[0] + '\n\n';
            if (valueMatches) scriptContent += valueMatches.join('\n\n');
            if (ctaMatch) scriptContent += '\n\n' + ctaMatch[0];
            
            if (scriptContent.trim()) {
              sections.script = cleanMarkdownFormat(scriptContent.trim());
              console.log('使用 Hook/Value/CTA 作為腳本內容:', sections.script.substring(0, 100) + '...');
            }
          }
          
          // 3. 提取畫面感
          const visualPatterns = [
            /畫面感[：:]\s*([\s\S]*?)(?=\n\s*(?:發佈文案|$))/i,
            /畫面[：:]\s*([\s\S]*?)(?=\n\s*(?:發佈文案|$))/i,
            /\d+\.\s*畫面感[：:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*發佈文案|$))/i,
            /\d+\.\s*畫面[：:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*發佈文案|$))/i
          ];
          
          for (const pattern of visualPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.visual = cleanMarkdownFormat(match[1].trim());
              console.log('找到畫面感:', sections.visual.substring(0, 100) + '...');
              break;
            }
          }
          
          // 4. 提取發佈文案
          const copyPatterns = [
            /發佈文案[：:]\s*([\s\S]*?)$/i,
            /文案[：:]\s*([\s\S]*?)$/i,
            /\d+\.\s*發佈文案[：:]\s*([\s\S]*?)$/i,
            /\d+\.\s*文案[：:]\s*([\s\S]*?)$/i
          ];
          
          for (const pattern of copyPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.copy = cleanMarkdownFormat(match[1].trim());
              console.log('找到發佈文案:', sections.copy.substring(0, 100) + '...');
              break;
            }
          }
          
          // 5. 如果沒有找到明確的標記，嘗試按段落分割
          if (!sections.title && !sections.script && !sections.visual && !sections.copy) {
            console.log('未找到明確標記，嘗試按段落分割...');
            const paragraphs = aiText.split('\n\n').filter(p => p.trim().length > 0);
            
            if (paragraphs.length >= 1) {
              sections.title = cleanMarkdownFormat(paragraphs[0].trim());
            }
            if (paragraphs.length >= 2) {
              sections.script = cleanMarkdownFormat(paragraphs[1].trim());
            }
            if (paragraphs.length >= 3) {
              sections.visual = cleanMarkdownFormat(paragraphs[2].trim());
            }
            if (paragraphs.length >= 4) {
              sections.copy = cleanMarkdownFormat(paragraphs[3].trim());
            }
          }
          
        } catch (error) {
          console.error('解析AI內容時出錯:', error);
        }
        
        console.log('最終解析結果:', sections);
        return sections;
      }
    </script>
  </body>
  </html>



