<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AIJobçŸ­å½±éŸ³æ™ºèƒ½é«”</title>
    <style>
      :root { color-scheme: light; }
      body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background:#ffffff; color:#1a1a1a; }
      .container { max-width: 900px; margin: 0 auto; padding: 16px; }
      
      /* æ‰‹æ©Ÿç‰ˆå„ªåŒ– */
      @media (max-width: 768px) {
        .container { padding: 12px; }
        h1 { font-size: 16px; margin-bottom: 12px; }
        .chat { height: 50vh; padding: 12px; }
        .msg-bubble { max-width: 85%; padding: 10px 14px; font-size: 14px; }
        .settings-block { padding: 16px; margin-bottom: 12px; }
        .settings-block h3 { font-size: 14px; margin-bottom: 12px; }
        .settings-grid { grid-template-columns: 1fr; gap: 10px; margin-bottom: 12px; }
        .setting-item input, .setting-item select { padding: 10px 12px; font-size: 16px; }
        .apply-btn { padding: 12px 16px; font-size: 14px; }
        .controls { flex-direction: column; gap: 10px; }
        .controls .row { flex-direction: row !important; justify-content: space-between; }
        .controls .row button { flex: 1; margin: 0 4px; }
        textarea { min-height: 50px; font-size: 16px; }
        button { padding: 12px 16px; font-size: 14px; }
        .results-block { padding: 16px; }
        .results-block h3 { font-size: 14px; }
        .result-item h4 { font-size: 13px; }
        .result-item .content { padding: 10px; font-size: 14px; }
        .toast { top: 10px; right: 10px; left: 10px; max-width: none; font-size: 13px; }
      }
      h1 { font-size: 18px; font-weight: 600; color:#2563eb; margin: 0 0 16px; }
      .chat { border: 1px solid #e5e7eb; background: #f9fafb; border-radius: 12px; height: 60vh; overflow: auto; padding: 16px; }
      .msg { margin: 12px 0; line-height: 1.6; display: flex; }
      .msg.user { justify-content: flex-end; }
      .msg.assistant { justify-content: flex-start; }
      .msg-bubble { max-width: 70%; padding: 12px 16px; border-radius: 18px; white-space: pre-wrap; word-wrap: break-word; }
      .msg.user .msg-bubble { background: #3b82f6; color: #ffffff; border-bottom-right-radius: 4px; }
      .msg.assistant .msg-bubble { background: #f3f4f6; color: #374151; border-bottom-left-radius: 4px; }
      .msg-label { font-size: 12px; color: #6b7280; margin-bottom: 4px; }
      .msg.user .msg-label { text-align: right; }
      .msg.assistant .msg-label { text-align: left; }
      
      /* è¼‰å…¥å‹•ç•« */
      .loading { display: flex; align-items: center; gap: 8px; }
      .spinner { width: 16px; height: 16px; border: 2px solid #e5e7eb; border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
      .controls { display: flex; gap: 8px; margin-top: 12px; align-items:center; }
      textarea { flex: 1; min-height: 44px; max-height: 140px; resize: vertical; border-radius: 10px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding: 10px 12px; line-height: 1.4; -webkit-appearance: none; }
      button { padding: 10px 14px; border-radius: 10px; border:1px solid #d1d5db; background:#f9fafb; color:#374151; cursor:pointer; -webkit-appearance: none; }
      button:disabled { opacity: .6; cursor:not-allowed; }
      .row { display:flex; gap:8px; flex-direction:column; }
      .meta { display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap; }
      .meta input, .meta select { flex:1; min-width: 200px; border-radius: 8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; padding:8px 10px; }
      .small { font-size:12px; color:#6b7280; }
      .tag { display:inline-block; padding:4px 8px; border:1px solid #d1d5db; border-radius:999px; font-size:12px; color:#6b7280; background:#f3f4f6; }
      
      /* è¨­å®šå€å¡Šæ¨£å¼ */
      .settings-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-bottom:16px; }
      .settings-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; cursor:pointer; user-select:none; display:flex; align-items:center; gap:8px; }
      .settings-block h3:hover { color:#1d4ed8; }
      .settings-toggle { font-size:12px; transition:transform 0.2s ease; }
      .settings-content { transition:all 0.3s ease; overflow:hidden; }
      .settings-content.collapsed { max-height:0; margin:0; padding:0; }
      .settings-grid { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin-bottom:16px; }
      .setting-item { display:flex; flex-direction:column; gap:6px; }
      .setting-item label { font-size:12px; color:#6b7280; font-weight:500; }
      .setting-item input, .setting-item select { padding:8px 12px; border-radius:8px; border:1px solid #d1d5db; background:#ffffff; color:#374151; -webkit-appearance: none; }
      .apply-btn { background:#3b82f6; border:1px solid #2563eb; color:#ffffff; padding:10px 20px; border-radius:8px; cursor:pointer; font-weight:500; }
      .apply-btn:hover { background:#2563eb; }
      .applied-tags { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
      
      /* çµæœå€å¡Šæ¨£å¼ */
      .results-block { background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; padding:20px; margin-top:16px; display:none; }
      .results-block h3 { margin:0 0 16px; color:#2563eb; font-size:16px; }
      .result-item { margin-bottom:16px; }
      .result-item h4 { margin:0 0 8px; color:#374151; font-size:14px; font-weight:500; }
      .result-item .content { background:#f9fafb; border:1px solid #e5e7eb; border-radius:8px; padding:12px; color:#374151; white-space:pre-wrap; line-height:1.6; }
      
      /* å½ˆå‡ºæ¡†æ¨£å¼ */
      .toast { position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; font-size: 14px; max-width: 300px; word-wrap: break-word; }
      .toast.show { animation: slideIn 0.3s ease-out; }
      .toast.hide { animation: slideOut 0.3s ease-in; }
      @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
      @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
      
      /* iOS Safari ç‰¹å®šå„ªåŒ– */
      @supports (-webkit-touch-callout: none) {
        .chat { -webkit-overflow-scrolling: touch; }
        textarea { -webkit-user-select: text; }
        input, select { -webkit-user-select: text; }
        .msg-bubble { -webkit-user-select: text; }
        .result-item .content { -webkit-user-select: text; }
      }
      
      /* é˜²æ­¢ iOS Safari ç¸®æ”¾ */
      input[type="text"], input[type="email"], input[type="password"], textarea, select { font-size: 16px; }
      
      /* å¿«é€ŸæŒ‰éˆ•æ¨£å¼ */
      .quick-buttons { 
        display: flex; 
        gap: 8px; 
        margin-bottom: 12px; 
        flex-wrap: wrap;
        justify-content: center;
      }
      .quick-btn { 
        padding: 8px 16px; 
        border-radius: 20px; 
        border: 1px solid #3b82f6; 
        background: #ffffff; 
        color: #3b82f6; 
        cursor: pointer; 
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      .quick-btn:hover { 
        background: #3b82f6; 
        color: #ffffff; 
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
      }
      .quick-btn:active { 
        transform: translateY(0); 
        box-shadow: 0 1px 4px rgba(59, 130, 246, 0.2);
      }
      
      /* æ‰‹æ©Ÿç‰ˆå¿«é€ŸæŒ‰éˆ•å„ªåŒ– */
      @media (max-width: 768px) {
        .quick-buttons { 
          gap: 6px; 
          margin-bottom: 10px;
        }
        .quick-btn { 
          padding: 6px 12px; 
          font-size: 13px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AIJobçŸ­å½±éŸ³æ™ºèƒ½é«”</h1>

      <!-- è¨­å®šå€å¡Š -->
      <div class="settings-block">
        <h3 id="settingsToggle">ğŸ“‹ çŸ­å½±éŸ³è¨­å®š <span class="settings-toggle">â–¼</span></h3>
        <div class="settings-content" id="settingsContent">
          <div class="settings-grid">
          <div class="setting-item">
            <label>å¹³å°</label>
            <select id="platform">
              <option value="">é¸æ“‡å¹³å°</option>
              <option value="Reels">IG Reels</option>
              <option value="TikTok">TikTok</option>
              <option value="å°ç´…æ›¸">å°ç´…æ›¸</option>
            </select>
          </div>
          <div class="setting-item">
            <label>ä¸»é¡Œ</label>
            <input id="topic" placeholder="ä¾‹å¦‚ï¼šå¤å­£è®Šç™½æŒ‘æˆ° / ç¾ç™½ä¿é¤Š" />
          </div>
          <div class="setting-item">
            <label>è…³æœ¬ç§’æ•¸</label>
            <select id="duration">
              <option value="30">30ç§’</option>
              <option value="60">60ç§’</option>
              <option value="90">90ç§’</option>
            </select>
          </div>
          <div class="setting-item">
            <label>å¸³è™Ÿå®šä½</label>
            <input id="profile" placeholder="å¦‚ï¼šå¥åº·Ã—åŠ å¯†ï¼Œè¼•é¬†å¹½é»˜" />
          </div>
        </div>
        <button id="apply" class="apply-btn">å¥—ç”¨è¨­å®š</button>
          <div class="applied-tags">
            <span id="platformBadge" class="tag" style="display:none;"></span>
            <span id="topicBadge" class="tag" style="display:none;"></span>
            <span id="durationBadge" class="tag" style="display:none;"></span>
          </div>
        </div>
      </div>

      <div id="chat" class="chat"></div>

      <!-- å¿«é€ŸæŒ‰éˆ•å€åŸŸ -->
      <div class="quick-buttons">
        <button class="quick-btn" data-text="è«‹å¹«æˆ‘ç”Ÿæˆä¸€å€‹å®Œæ•´çš„çŸ­å½±éŸ³è…³æœ¬ï¼ŒåŒ…å«ä¸»é¡Œæ¨™é¡Œã€è…³æœ¬å…§å®¹ã€ç•«é¢æ„Ÿå’Œç™¼ä½ˆæ–‡æ¡ˆ">ç”Ÿæˆè…³æœ¬</button>
        <button class="quick-btn" data-text="è«‹å¹«æˆ‘æ¨è–¦ä¸€äº›ç†±é–€çš„çŸ­å½±éŸ³é¸é¡Œå’Œè©±é¡Œæ–¹å‘">è…³æœ¬é¸é¡Œ</button>
        <button class="quick-btn" data-text="è«‹å¹«æˆ‘åˆ†æä¸¦å»ºè­°é©åˆçš„å¸³è™Ÿå®šä½ç­–ç•¥ï¼ŒåŒ…æ‹¬å…§å®¹æ–¹å‘å’Œç›®æ¨™å—çœ¾">å¸³è™Ÿå®šä½</button>
      </div>

      <div class="controls">
        <textarea id="input" placeholder="è¼¸å…¥è¨Šæ¯â€¦ï¼ˆCtrl+Enter é€å‡ºã€Enter æ›è¡Œï¼‰"></textarea>
        <div class="row">
          <button id="send">é€å‡º</button>
          <button id="showResults">é¡¯ç¤ºçµæœå€å¡Š</button>
          <button id="testConnection">ğŸ”§ æ¸¬è©¦é€£ç·š</button>
        </div>
      </div>
      <div id="status" class="small"></div>
      
      <!-- çµæœå€å¡Š -->
      <div id="results" class="results-block">
        <h3>ğŸ“ çŸ­å½±éŸ³è…³æœ¬çµæœ</h3>
        <div class="result-item">
          <h4>ğŸ¯ ä¸»é¡Œ</h4>
          <div id="result-title" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ“œ è…³æœ¬å…§å®¹</h4>
          <div id="result-script" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ¬ ç•«é¢æ„Ÿ</h4>
          <div id="result-visual" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
        <div class="result-item">
          <h4>ğŸ“± æ–‡æ¡ˆ</h4>
          <div id="result-copy" class="content">å°šæœªç”Ÿæˆ</div>
        </div>
      </div>
      
      <div class="small">2025 AIJobå­¸é™¢ç‰ˆæ¬Šæ‰€æœ‰</div>
    </div>

    <!-- å½ˆå‡ºæç¤ºæ¡† -->
    <div id="toast" class="toast" style="display: none;"></div>


    <script>
      const chatEl = document.getElementById('chat');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');
      const showResultsBtn = document.getElementById('showResults');
      const applyBtn = document.getElementById('apply');
      const platformEl = document.getElementById('platform');
      const topicEl = document.getElementById('topic');
      const durationEl = document.getElementById('duration');
      const profileEl = document.getElementById('profile');
      const platformBadge = document.getElementById('platformBadge');
      const topicBadge = document.getElementById('topicBadge');
      const durationBadge = document.getElementById('durationBadge');
      const statusEl = document.getElementById('status');
      const resultsEl = document.getElementById('results');
      const resultTitleEl = document.getElementById('result-title');
      const resultScriptEl = document.getElementById('result-script');
      const resultVisualEl = document.getElementById('result-visual');
      const resultCopyEl = document.getElementById('result-copy');
      const toastEl = document.getElementById('toast');
      const settingsToggleEl = document.getElementById('settingsToggle');
      const settingsContentEl = document.getElementById('settingsContent');
      const testConnectionBtn = document.getElementById('testConnection');

      let history = [];
      let lastMessage = '';
      let isSending = false;
      let lastSubmitAt = 0;
      let platformCurrent = '';
      let topicCurrent = '';
      let durationCurrent = '30';
      const styleInstruction = 'æ ¼å¼è¦æ±‚ï¼šåˆ†æ®µæ¸…æ¥šï¼ŒçŸ­å¥ï¼Œæ¯æ®µæ›è¡Œï¼Œé©åº¦åŠ å…¥è¡¨æƒ…ç¬¦è™Ÿï¼ˆå¦‚ï¼šâœ…âœ¨ğŸ”¥ğŸ“Œï¼‰ï¼Œé¿å…å£é ­ç¦ªã€‚çµ•å°ä¸è¦ä½¿ç”¨ ** æˆ–ä»»ä½• Markdown æ ¼å¼ç¬¦è™Ÿï¼Œæ‰€æœ‰å…§å®¹å¿…é ˆæ˜¯ç´”æ–‡å­—æ ¼å¼ã€‚';

      // å½ˆå‡ºæç¤ºæ¡†å‡½æ•¸
      function showToast(message, duration = 3000) {
        toastEl.textContent = message;
        toastEl.style.display = 'block';
        toastEl.className = 'toast show';
        
        setTimeout(() => {
          toastEl.className = 'toast hide';
          setTimeout(() => {
            toastEl.style.display = 'none';
          }, 300);
        }, duration);
      }

      // é¦–æ¬¡è¼‰å…¥é¡¯ç¤ºå¼•å°è¨Šæ¯
      document.addEventListener('DOMContentLoaded', () => {
        append('assistant', [
          'å—¨ï½å…ˆå¹«æˆ‘è¨­å®šï¼š',
          '1) é¸æ“‡å¹³å°ã€è¼¸å…¥ä¸»é¡Œèˆ‡å¸³è™Ÿå®šä½ï¼ŒæŒ‰ã€Œå¥—ç”¨ã€âœ…',
          '2) åœ¨ä¸‹æ–¹è¼¸å…¥ä½ æƒ³èŠçš„å…§å®¹ï¼ˆæˆ‘æœƒç”¨æ®µè½ï¼‹emoji å›è¦†ï¼‰âœ¨',
          '3) ä»»ä½•æ™‚å€™éƒ½å¯é‡æ–°ã€Œå¥—ç”¨ã€èª¿æ•´è¨­å®š ğŸ”„'
        ].join('\n'));
      });

      function append(role, text) {
        const div = document.createElement('div');
        div.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');
        
        const label = document.createElement('div');
        label.className = 'msg-label';
        label.textContent = role === 'user' ? 'ä½ ' : 'AI';
        
        const bubble = document.createElement('div');
        bubble.className = 'msg-bubble';
        
        // å¦‚æœæ˜¯ AI å›è¦†ï¼Œæ¸…ç† Markdown æ ¼å¼
        if (role === 'assistant') {
          const cleanText = cleanMarkdownFormat(text);
          bubble.innerHTML = cleanText;
        } else {
          bubble.textContent = text;
        }
        
        div.appendChild(label);
        div.appendChild(bubble);
        chatEl.appendChild(div);
        chatEl.scrollTop = chatEl.scrollHeight;
        return { container: div, bubble: bubble };
      }

      // æ¸…ç† Markdown æ ¼å¼ä¸¦è½‰æ›ç‚º HTML
      function cleanMarkdownFormat(text) {
        // è™•ç† Markdown æ¨™é¡Œæ ¼å¼
        text = text.replace(/^###\s*(.+)$/gm, '<strong>$1</strong>'); // ### æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        text = text.replace(/^##\s*(.+)$/gm, '<strong>$1</strong>');  // ## æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        text = text.replace(/^#\s*(.+)$/gm, '<strong>$1</strong>');   // # æ¨™é¡Œ â†’ **æ¨™é¡Œ**
        
        // å°‡ **æ–‡å­—** è½‰æ›ç‚º <strong>æ–‡å­—</strong>
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        // è™•ç†å…¶ä»–å¸¸è¦‹çš„ Markdown æ ¼å¼
        text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');           // *æ–œé«”* â†’ æ–œé«”
        text = text.replace(/`([^`]+)`/g, '<code>$1</code>');         // `ä»£ç¢¼` â†’ ä»£ç¢¼
        
        // ç§»é™¤å–®ç¨çš„ Markdown ç¬¦è™Ÿ
        text = text.replace(/\*\*/g, '');                             // ç§»é™¤å–®ç¨çš„ **
        text = text.replace(/^#{1,6}\s*/gm, '');                      // ç§»é™¤è¡Œé¦–çš„ # ç¬¦è™Ÿ
        
        return text;
      }

      function updateAssistantNode(nodeObj, text) {
        // æ¸…ç† Markdown æ ¼å¼
        const cleanText = cleanMarkdownFormat(text);
        
        if (nodeObj.bubble) {
          // ä½¿ç”¨ innerHTML ä¾†æ”¯æ´ HTML æ¨™ç±¤ï¼ˆå¦‚ <strong>ï¼‰
          nodeObj.bubble.innerHTML = cleanText;
        } else {
          nodeObj.innerHTML = cleanText;
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }

      function canSubmit() {
        if (isSending) return false;
        const now = Date.now();
        if (now - lastSubmitAt < 600) return false; // 600ms ç¯€æµ
        lastSubmitAt = now;
        return true;
      }

      async function send(message) {
        if (!message) return;
        if (!canSubmit()) return;
        lastMessage = message;
        const userNode = append('user', message);
        const assistantNode = append('assistant', '');

        // é¡¯ç¤º AI å›è¦†ä¸­çš„è¼‰å…¥ç‹€æ…‹
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'loading';
        loadingDiv.innerHTML = '<div class="spinner"></div><span>AIå›è¦†ä¸­...</span>';
        assistantNode.bubble.appendChild(loadingDiv);

        sendBtn.disabled = true;
        isSending = true;
        statusEl.textContent = 'æ­£åœ¨é€å‡ºâ€¦';

        try {
          // è‡ªå‹•åµæ¸¬ç’°å¢ƒï¼Œé–‹ç™¼æ™‚ä½¿ç”¨ localhostï¼Œéƒ¨ç½²æ™‚ä½¿ç”¨ç’°å¢ƒè®Šæ•¸æˆ–é è¨­å¾Œç«¯ç¶²åŸŸ
          const isDevelopment = window.location.hostname === 'localhost' || 
                                window.location.hostname === '127.0.0.1' ||
                                window.location.hostname === '0.0.0.0';
          
          // å¦‚æœæ˜¯é–‹ç™¼ç’°å¢ƒï¼Œä½¿ç”¨ localhost:8000ï¼›éƒ¨ç½²ç’°å¢ƒä½¿ç”¨æ­£ç¢ºçš„å¾Œç«¯ç¶²åŸŸ
          let endpoint;
          if (isDevelopment) {
            endpoint = 'http://127.0.0.1:8000/api/chat/stream';
          } else {
            // éƒ¨ç½²ç’°å¢ƒï¼šä½¿ç”¨æ‚¨æä¾›çš„æ­£ç¢ºå¾Œç«¯ç¶²åŸŸ
            endpoint = 'https://aivideobackend.zeabur.app/api/chat/stream';
          }
          // æ·»åŠ èª¿è©¦ä¿¡æ¯
          console.log('API ç«¯é»:', endpoint);
          console.log('ç•¶å‰ä½ç½®:', window.location.href);
          console.log('Hostname:', window.location.hostname);
          console.log('Port:', window.location.port);
          
          const res = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message,
              platform: (platformCurrent || platformEl?.value || '') || null,
              topic: (topicCurrent || topicEl?.value || '') || null,
              duration: (durationCurrent || durationEl?.value || '30'),
              style: styleInstruction,
              profile: (profileEl?.value || '') || null,
              history
            })
          });

          if (!res.ok) {
            const text = await res.text().catch(() => '');
            console.error('API è«‹æ±‚å¤±æ•—:', res.status, text);
            
            let errorMessage = `[è«‹æ±‚å¤±æ•— ${res.status}] `;
            try {
              const errorData = JSON.parse(text);
              if (errorData.error) {
                errorMessage += errorData.error;
                if (errorData.error.includes('GEMINI_API_KEY')) {
                  errorMessage += '\n\nğŸ’¡ è§£æ±ºæ–¹æ¡ˆï¼šè«‹åœ¨ Zeabur å¾Œç«¯æœå‹™çš„ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š GEMINI_API_KEY';
                }
              } else {
                errorMessage += text || 'ç„¡å›æ‡‰å…§å®¹';
              }
            } catch {
              errorMessage += text || 'ç„¡å›æ‡‰å…§å®¹';
            }
            
            updateAssistantNode(assistantNode, errorMessage);
            return;
          }

          const reader = res.body.getReader();
          const decoder = new TextDecoder('utf-8');
          let aiText = '';
          let buffer = '';

          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let idx;
            while ((idx = buffer.indexOf('\n\n')) !== -1) {
              const frame = buffer.slice(0, idx).trim();
              buffer = buffer.slice(idx + 2);
              if (!frame.startsWith('data:')) continue;
              try {
                const jsonStr = frame.slice(5).trim();
                const evt = JSON.parse(jsonStr);
                if (evt.type === 'token') {
                  // ç§»é™¤è¼‰å…¥å‹•ç•«ï¼Œé–‹å§‹é¡¯ç¤º AI å›è¦†
                  const loadingDiv = assistantNode.bubble.querySelector('.loading');
                  if (loadingDiv) {
                    loadingDiv.remove();
                  }
                  aiText += evt.content;
                  updateAssistantNode(assistantNode, aiText);
                } else if (evt.type === 'end') {
                  history.push({ role: 'user', content: message });
                  history.push({ role: 'assistant', content: aiText });
                  
                  // æª¢æŸ¥æ˜¯å¦åŒ…å«è…³æœ¬çµæœï¼Œè‡ªå‹•é¡¯ç¤ºçµæœå€å¡Š
                  checkAndUpdateResults(aiText);
                }
              } catch (e) { /* ignore parse errors */ }
            }
          }
        } catch (e) {
          // ç§»é™¤è¼‰å…¥å‹•ç•«ï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
          const loadingDiv = assistantNode.bubble.querySelector('.loading');
          if (loadingDiv) {
            loadingDiv.remove();
          }
          console.error('è«‹æ±‚éŒ¯èª¤:', e);
          console.error('éŒ¯èª¤è©³æƒ…:', {
            message: e?.message,
            name: e?.name,
            stack: e?.stack,
            endpoint: endpoint,
            location: window.location.href
          });
          
          // æä¾›æ›´è©³ç´°çš„éŒ¯èª¤è¨Šæ¯
          let errorMsg = `[éŒ¯èª¤] ${e?.message || e}`;
          if (e?.name === 'TypeError' && e?.message.includes('fetch')) {
            errorMsg = '[é€£ç·šéŒ¯èª¤] ç„¡æ³•é€£æ¥åˆ°ä¼ºæœå™¨ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦';
          } else if (e?.name === 'TypeError' && e?.message.includes('Failed to fetch')) {
            errorMsg = '[ç¶²è·¯éŒ¯èª¤] è«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–é‡æ–°æ•´ç†é é¢';
          } else if (e?.message?.includes('CORS')) {
            errorMsg = '[è·¨åŸŸéŒ¯èª¤] è«‹å˜—è©¦é‡æ–°æ•´ç†é é¢';
          }
          
          // æ·»åŠ æ›´å¤šèª¿è©¦ä¿¡æ¯
          errorMsg += `\n\nèª¿è©¦ä¿¡æ¯ï¼š\nç«¯é»: ${endpoint}\nä½ç½®: ${window.location.href}`;
          updateAssistantNode(assistantNode, errorMsg);
        } finally {
          sendBtn.disabled = false;
          isSending = false;
          statusEl.textContent = '';
        }
      }

      sendBtn.addEventListener('click', () => {
        if (sendBtn.disabled || isSending) return;
        const text = inputEl.value.trim();
        if (!text) return;
        inputEl.value = '';
        send(text);
      });

      inputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.ctrlKey) {
          if (sendBtn.disabled || isSending) return;
          e.preventDefault();
          const text = inputEl.value.trim();
          if (!text) return;
          inputEl.value = '';
          send(text);
        }
      });

      showResultsBtn.addEventListener('click', () => {
        resultsEl.style.display = resultsEl.style.display === 'none' ? 'block' : 'none';
        showResultsBtn.textContent = resultsEl.style.display === 'none' ? 'é¡¯ç¤ºçµæœå€å¡Š' : 'éš±è—çµæœå€å¡Š';
      });

      // è¨­å®šå€å¡Šæ‘ºç–Š/å±•é–‹åŠŸèƒ½
      settingsToggleEl.addEventListener('click', () => {
        const isCollapsed = settingsContentEl.classList.contains('collapsed');
        const toggleIcon = settingsToggleEl.querySelector('.settings-toggle');
        
        if (isCollapsed) {
          settingsContentEl.classList.remove('collapsed');
          toggleIcon.textContent = 'â–¼';
        } else {
          settingsContentEl.classList.add('collapsed');
          toggleIcon.textContent = 'â–¶';
        }
      });

      applyBtn.addEventListener('click', () => {
        platformCurrent = (platformEl?.value || '');
        topicCurrent = (topicEl?.value || '');
        durationCurrent = (durationEl?.value || '30');
        
        // æ›´æ–°å¾½ç« é¡¯ç¤º
        updateBadge(platformBadge, 'å¹³å°', platformCurrent);
        updateBadge(topicBadge, 'ä¸»é¡Œ', topicCurrent);
        updateBadge(durationBadge, 'ç§’æ•¸', durationCurrent + 'ç§’');

        // å¥—ç”¨å¾Œé¡¯ç¤ºå½ˆå‡ºæç¤ºæ¡†
        const message = `è¨­å®šå·²å¥—ç”¨ï¼\nå¹³å°ï¼š${platformCurrent || 'æœªé¸æ“‡'}\nä¸»é¡Œï¼š${topicCurrent || 'æœªè¼¸å…¥'}\nç§’æ•¸ï¼š${durationCurrent}ç§’`;
        showToast(message);
      });

      function updateBadge(badgeEl, label, value) {
        if (value) {
          badgeEl.style.display = 'inline-block';
          badgeEl.textContent = label + 'ï¼š' + value;
        } else {
          badgeEl.style.display = 'none';
          badgeEl.textContent = '';
        }
      }

      // æ¸¬è©¦é€£ç·šåŠŸèƒ½
      async function testConnection() {
        const testNode = append('assistant', 'ğŸ”§ æ­£åœ¨æ¸¬è©¦é€£ç·š...');
        
        try {
          // æ¸¬è©¦å¾Œç«¯æ ¹è·¯å¾‘
          const rootResponse = await fetch('https://aivideobackend.zeabur.app/');
          const rootText = await rootResponse.text();
          
          let testResult = `ğŸ” é€£ç·šæ¸¬è©¦çµæœï¼š\n\n`;
          testResult += `1ï¸âƒ£ å¾Œç«¯æ ¹è·¯å¾‘ï¼š${rootResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'} (ç‹€æ…‹ç¢¼: ${rootResponse.status})\n`;
          
          // æ¸¬è©¦å¥åº·æª¢æŸ¥
          try {
            const healthResponse = await fetch('https://aivideobackend.zeabur.app/api/health');
            const healthData = await healthResponse.json();
            
            testResult += `2ï¸âƒ£ å¥åº·æª¢æŸ¥ï¼š${healthResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'}\n`;
            testResult += `   - çŸ¥è­˜åº«ï¼š${healthData.kb_status}\n`;
            testResult += `   - Geminié…ç½®ï¼š${healthData.gemini_configured ? 'âœ… å·²é…ç½®' : 'âŒ æœªé…ç½®'}\n`;
            testResult += `   - Geminiæ¸¬è©¦ï¼š${healthData.gemini_test}\n`;
            testResult += `   - æ¨¡å‹ï¼š${healthData.model_name}\n`;
            
            if (!healthData.gemini_configured) {
              testResult += `\nâš ï¸ å•é¡Œï¼šGemini API Key æœªé…ç½®\n`;
              testResult += `ğŸ’¡ è§£æ±ºæ–¹æ¡ˆï¼šè«‹åœ¨ Zeabur å¾Œç«¯ç’°å¢ƒè®Šæ•¸ä¸­è¨­å®š GEMINI_API_KEY\n`;
            } else if (healthData.gemini_test !== 'working') {
              testResult += `\nâš ï¸ å•é¡Œï¼šGemini API é€£ç·šç•°å¸¸\n`;
              testResult += `ğŸ’¡ éŒ¯èª¤ï¼š${healthData.gemini_test}\n`;
            }
            
          } catch (healthError) {
            testResult += `2ï¸âƒ£ å¥åº·æª¢æŸ¥ï¼šâŒ ç„¡æ³•é€£ç·š (${healthError.message})\n`;
          }
          
          // æ¸¬è©¦èŠå¤©API
          try {
            const chatResponse = await fetch('https://aivideobackend.zeabur.app/api/chat/stream', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message: 'test', platform: null, topic: null, duration: '30' })
            });
            
            testResult += `3ï¸âƒ£ èŠå¤©APIï¼š${chatResponse.ok ? 'âœ… æ­£å¸¸' : 'âŒ ç•°å¸¸'} (ç‹€æ…‹ç¢¼: ${chatResponse.status})\n`;
            
            if (!chatResponse.ok) {
              const errorText = await chatResponse.text();
              testResult += `   éŒ¯èª¤ï¼š${errorText}\n`;
            }
            
          } catch (chatError) {
            testResult += `3ï¸âƒ£ èŠå¤©APIï¼šâŒ ç„¡æ³•é€£ç·š (${chatError.message})\n`;
          }
          
          updateAssistantNode(testNode, testResult);
          
        } catch (error) {
          updateAssistantNode(testNode, `âŒ é€£ç·šæ¸¬è©¦å¤±æ•—ï¼š${error.message}`);
        }
      }

      // ç¶å®šæ¸¬è©¦é€£ç·šæŒ‰éˆ•
      testConnectionBtn.addEventListener('click', testConnection);

      // æ·»åŠ å…¨å±€æ¸¬è©¦å‡½æ•¸ï¼ˆç”¨æ–¼èª¿è©¦ï¼‰
      window.testDOM = function() {
        console.log('=== DOMå…ƒç´ æ¸¬è©¦ ===');
        console.log('resultTitleEl:', resultTitleEl);
        console.log('resultScriptEl:', resultScriptEl);
        console.log('resultVisualEl:', resultVisualEl);
        console.log('resultCopyEl:', resultCopyEl);
        
        if (resultTitleEl) {
          resultTitleEl.innerHTML = 'æ¸¬è©¦æ¨™é¡Œ';
          console.log('æ¸¬è©¦æ¨™é¡Œè¨­ç½®æˆåŠŸ');
        }
        if (resultScriptEl) {
          resultScriptEl.innerHTML = 'æ¸¬è©¦è…³æœ¬å…§å®¹';
          console.log('æ¸¬è©¦è…³æœ¬å…§å®¹è¨­ç½®æˆåŠŸ');
        }
        if (resultVisualEl) {
          resultVisualEl.innerHTML = 'æ¸¬è©¦ç•«é¢æ„Ÿ';
          console.log('æ¸¬è©¦ç•«é¢æ„Ÿè¨­ç½®æˆåŠŸ');
        }
        if (resultCopyEl) {
          resultCopyEl.innerHTML = 'æ¸¬è©¦ç™¼ä½ˆæ–‡æ¡ˆ';
          console.log('æ¸¬è©¦ç™¼ä½ˆæ–‡æ¡ˆè¨­ç½®æˆåŠŸ');
        }
      };

      // å¿«é€ŸæŒ‰éˆ•åŠŸèƒ½
      document.querySelectorAll('.quick-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const text = btn.getAttribute('data-text');
          if (text) {
            inputEl.value = text;
            inputEl.focus();
            
            // æ·»åŠ è¦–è¦ºåé¥‹
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => {
              btn.style.transform = '';
            }, 150);
            
            // å¯é¸ï¼šè‡ªå‹•ç™¼é€ï¼ˆå¦‚æœéœ€è¦å¯ä»¥å–æ¶ˆè¨»é‡‹ï¼‰
            // if (text.trim()) {
            //   send(text);
            // }
          }
        });
      });

      function checkAndUpdateResults(aiText) {
        console.log('=== é–‹å§‹è§£æAIå›æ‡‰ ===');
        console.log('AIå›æ‡‰é•·åº¦:', aiText.length);
        console.log('AIå›æ‡‰å‰300å­—ç¬¦:', aiText.substring(0, 300));
        
        // æ›´ç²¾ç¢ºçš„è…³æœ¬å…§å®¹æª¢æ¸¬
        const isScriptContent = detectScriptContent(aiText);
        
        console.log('æ˜¯å¦ç‚ºè…³æœ¬å…§å®¹:', isScriptContent);
        
        if (isScriptContent) {
          // é¡¯ç¤ºçµæœå€å¡Š
          resultsEl.style.display = 'block';
          console.log('çµæœå€å¡Šå·²é¡¯ç¤ºï¼Œé–‹å§‹è§£æå…§å®¹...');
          
          // ç¢ºä¿DOMå…ƒç´ å­˜åœ¨
          if (!resultTitleEl || !resultScriptEl || !resultVisualEl || !resultCopyEl) {
            console.error('DOMå…ƒç´ ä¸å­˜åœ¨:', {
              resultTitleEl: !!resultTitleEl,
              resultScriptEl: !!resultScriptEl,
              resultVisualEl: !!resultVisualEl,
              resultCopyEl: !!resultCopyEl
            });
            return;
          }
          
          try {
            // ä½¿ç”¨æ›´éˆæ´»çš„è§£ææ–¹æ³•
            const sections = parseAIContent(aiText);
            
            // æ›´æ–°DOMå…ƒç´ 
            if (sections.title) {
              resultTitleEl.innerHTML = sections.title;
              console.log('âœ… ä¸»é¡Œæ¨™é¡Œå·²è¨­ç½®:', sections.title);
            }
            
            if (sections.script) {
              resultScriptEl.innerHTML = sections.script;
              console.log('âœ… è…³æœ¬å…§å®¹å·²è¨­ç½®:', sections.script.substring(0, 100) + '...');
            }
            
            if (sections.visual) {
              resultVisualEl.innerHTML = sections.visual;
              console.log('âœ… ç•«é¢æ„Ÿå·²è¨­ç½®:', sections.visual.substring(0, 100) + '...');
            }
            
            if (sections.copy) {
              resultCopyEl.innerHTML = sections.copy;
              console.log('âœ… ç™¼ä½ˆæ–‡æ¡ˆå·²è¨­ç½®:', sections.copy.substring(0, 100) + '...');
            }
            
            // å»¶é²æª¢æŸ¥å…§å®¹æ˜¯å¦æ­£ç¢ºè¨­ç½®
            setTimeout(() => {
              console.log('=== å»¶é²æª¢æŸ¥DOMå…§å®¹ ===');
              console.log('ä¸»é¡Œæ¨™é¡Œ:', resultTitleEl.innerHTML);
              console.log('è…³æœ¬å…§å®¹:', resultScriptEl.innerHTML.substring(0, 100) + '...');
              console.log('ç•«é¢æ„Ÿ:', resultVisualEl.innerHTML.substring(0, 100) + '...');
              console.log('ç™¼ä½ˆæ–‡æ¡ˆ:', resultCopyEl.innerHTML.substring(0, 100) + '...');
            }, 500);
            
          } catch (e) {
            console.error('è§£æçµæœæ™‚å‡ºéŒ¯:', e);
          }
        } else {
          console.log('æœªæª¢æ¸¬åˆ°è…³æœ¬å…§å®¹ï¼Œä¸é¡¯ç¤ºçµæœå€å¡Š');
        }
      }
      
      // æ–°å¢ï¼šç²¾ç¢ºçš„è…³æœ¬å…§å®¹æª¢æ¸¬å‡½æ•¸
      function detectScriptContent(aiText) {
        console.log('=== é–‹å§‹è…³æœ¬å…§å®¹æª¢æ¸¬ ===');
        console.log('æª¢æ¸¬æ–‡æœ¬é•·åº¦:', aiText.length);
        console.log('æª¢æ¸¬æ–‡æœ¬å‰200å­—ç¬¦:', aiText.substring(0, 200));
        
        // 1. æª¢æŸ¥æ˜¯å¦åŒ…å«è…³æœ¬ç›¸é—œçš„çµæ§‹æ¨™è¨˜ï¼ˆæ›´éˆæ´»çš„æª¢æ¸¬ï¼‰
        const structureMarkers = [
          /ä¸»é¡Œæ¨™é¡Œ[ï¼š:]/i,
          /è…³æœ¬å…§å®¹[ï¼š:]/i,
          /ç•«é¢æ„Ÿ[ï¼š:]/i,
          /ç™¼ä½ˆæ–‡æ¡ˆ[ï¼š:]/i,
          /\d+\.\s*ä¸»é¡Œæ¨™é¡Œ/i,
          /\d+\.\s*è…³æœ¬å…§å®¹/i,
          /\d+\.\s*ç•«é¢æ„Ÿ/i,
          /\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ/i,
          /Hook\s*\(\d+-\d+ç§’\)/i,
          /Value\s*\d+\s*\(\d+-\d+ç§’\)/i,
          /CTA\s*\(\d+-\d+ç§’\)/i
        ];
        
        const hasStructureMarkers = structureMarkers.some(pattern => pattern.test(aiText));
        console.log('æ˜¯å¦åŒ…å«è…³æœ¬çµæ§‹æ¨™è¨˜:', hasStructureMarkers);
        
        // 2. æª¢æŸ¥æ˜¯å¦åŒ…å«çŸ­å½±éŸ³è…³æœ¬çš„é—œéµå…ƒç´ 
        const scriptElements = [
          /Hook\s*\(\d+-\d+ç§’\)/i,
          /Value\s*\d+\s*\(\d+-\d+ç§’\)/i,
          /CTA\s*\(\d+-\d+ç§’\)/i,
          /ç•«é¢æ„Ÿ[ï¼š:]/i,
          /ç™¼ä½ˆæ–‡æ¡ˆ[ï¼š:]/i,
          /\d+\.\s*ç•«é¢æ„Ÿ/i,
          /\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ/i,
          /é¡é ­[ï¼š:]/i,
          /éŸ³æ•ˆ[ï¼š:]/i,
          /å­—å¹•[ï¼š:]/i,
          /å°è©[ï¼š:]/i
        ];
        
        const scriptElementCount = scriptElements.filter(pattern => pattern.test(aiText)).length;
        console.log('è…³æœ¬å…ƒç´ æ•¸é‡:', scriptElementCount);
        
        // å¦‚æœæ²’æœ‰è…³æœ¬çµæ§‹æ¨™è¨˜ä¸”è…³æœ¬å…ƒç´ å°‘æ–¼3å€‹ï¼Œç›´æ¥è¿”å› false
        if (!hasStructureMarkers && scriptElementCount < 3) {
          console.log('âŒ æœªåŒ…å«è¶³å¤ çš„è…³æœ¬çµæ§‹æ¨™è¨˜ï¼Œä¸é¡¯ç¤ºçµæœå€å¡Š');
          return false;
        }
        
        // 2. æª¢æŸ¥æ˜¯å¦åŒ…å«è…³æœ¬ç›¸é—œçš„é—œéµè©çµ„åˆ
        const scriptKeywords = ['ä¸»é¡Œæ¨™é¡Œ', 'è…³æœ¬å…§å®¹', 'ç•«é¢æ„Ÿ', 'ç™¼ä½ˆæ–‡æ¡ˆ', 'Hook', 'Value', 'CTA'];
        const keywordCount = scriptKeywords.filter(keyword => aiText.includes(keyword)).length;
        console.log('è…³æœ¬é—œéµè©æ•¸é‡:', keywordCount);
        
        // 3. æª¢æŸ¥æ˜¯å¦åŒ…å«çŸ­å½±éŸ³ç›¸é—œçš„å…§å®¹æŒ‡ç¤ºè©
        const videoIndicators = [
          'çŸ­å½±éŸ³è…³æœ¬',
          'çŸ­å½±éŸ³è…³æœ¬çµæœ',
          'ç”Ÿæˆè…³æœ¬',
          'è…³æœ¬ç”Ÿæˆ',
          'Reels',
          'TikTok',
          'å°ç´…æ›¸',
          'ç§’è…³æœ¬',
          'å½±éŸ³å…§å®¹',
          'çŸ­å½±éŸ³',
          'è…³æœ¬'
        ];
        const hasVideoIndicators = videoIndicators.some(indicator => aiText.includes(indicator));
        console.log('æ˜¯å¦åŒ…å«çŸ­å½±éŸ³æŒ‡ç¤ºè©:', hasVideoIndicators);
        
        // 4. æª¢æŸ¥æ–‡æœ¬é•·åº¦ï¼ˆè…³æœ¬å…§å®¹é€šå¸¸è¼ƒé•·ï¼‰
        const isLongEnough = aiText.length > 300; // æé«˜é•·åº¦è¦æ±‚
        console.log('æ–‡æœ¬æ˜¯å¦è¶³å¤ é•·:', isLongEnough);
        
        // 5. æª¢æŸ¥æ˜¯å¦åŒ…å«å¤šå€‹æ®µè½ï¼ˆè…³æœ¬é€šå¸¸æœ‰å¤šå€‹éƒ¨åˆ†ï¼‰
        const paragraphCount = aiText.split('\n\n').filter(p => p.trim().length > 0).length;
        const hasMultipleParagraphs = paragraphCount >= 4; // æé«˜æ®µè½è¦æ±‚
        console.log('æ®µè½æ•¸é‡:', paragraphCount, 'æ˜¯å¦å¤šæ®µè½:', hasMultipleParagraphs);
        
        // 6. æ’é™¤æ˜é¡¯çš„éè…³æœ¬å…§å®¹
        const nonScriptIndicators = [
          'ä½ å¥½',
          'è¬è¬',
          'ä¸å®¢æ°£',
          'è«‹å•',
          'ä¸å¥½æ„æ€',
          'æŠ±æ­‰',
          'æˆ‘ä¾†å¹«ä½ ',
          'è®“æˆ‘ç‚ºä½ ',
          'å¾ˆé«˜èˆˆç‚ºæ‚¨',
          'æ­¡è¿',
          'å†è¦‹',
          'æ‹œæ‹œ',
          'æœ‰ä»€éº¼å¯ä»¥å¹«ä½ ',
          'éœ€è¦ä»€éº¼å¹«åŠ©',
          'è«‹å‘Šè¨´æˆ‘',
          'è«‹è¼¸å…¥',
          'è«‹é¸æ“‡',
          'è«‹é»æ“Š',
          'è«‹æŸ¥çœ‹',
          'è«‹æ³¨æ„',
          'æé†’',
          'å»ºè­°',
          'æ¨è–¦',
          'ä»‹ç´¹',
          'èªªæ˜',
          'è§£é‡‹',
          'å›ç­”',
          'å›è¦†',
          'å›æ‡‰'
        ];
        const hasNonScriptIndicators = nonScriptIndicators.some(indicator => 
          aiText.toLowerCase().includes(indicator.toLowerCase())
        );
        console.log('æ˜¯å¦åŒ…å«éè…³æœ¬æŒ‡ç¤ºè©:', hasNonScriptIndicators);
        
        // 7. æª¢æŸ¥æ˜¯å¦åŒ…å«å®Œæ•´çš„è…³æœ¬çµæ§‹ï¼ˆè‡³å°‘åŒ…å«3å€‹å€å¡Šï¼‰
        const structureCount = requiredStructureMarkers.filter(pattern => pattern.test(aiText)).length;
        const hasCompleteStructure = structureCount >= 3;
        console.log('çµæ§‹å€å¡Šæ•¸é‡:', structureCount, 'æ˜¯å¦å®Œæ•´çµæ§‹:', hasCompleteStructure);
        
        // 8. æª¢æŸ¥æ˜¯å¦åŒ…å«æ™‚é–“æ¨™è¨˜ï¼ˆè…³æœ¬é€šå¸¸æœ‰æ™‚é–“æ¨™è¨˜ï¼‰
        const timeMarkers = [
          /\d+[-\s]*\d*\s*ç§’/i,
          /\d+[-\s]*\d*\s*åˆ†é˜/i,
          /0-\d+\s*ç§’/i,
          /\d+-\d+\s*ç§’/i
        ];
        const hasTimeMarkers = timeMarkers.some(pattern => pattern.test(aiText));
        console.log('æ˜¯å¦åŒ…å«æ™‚é–“æ¨™è¨˜:', hasTimeMarkers);
        
        // ç¶œåˆåˆ¤æ–·
        const score = {
          structureMarkers: hasStructureMarkers ? 3 : 0,
          scriptElements: Math.min(scriptElementCount, 4), // è…³æœ¬å…ƒç´ æ•¸é‡
          keywordCount: Math.min(keywordCount, 3),
          videoIndicators: hasVideoIndicators ? 2 : 0,
          length: isLongEnough ? 1 : 0,
          paragraphs: hasMultipleParagraphs ? 1 : 0,
          completeStructure: hasCompleteStructure ? 2 : 0,
          timeMarkers: hasTimeMarkers ? 1 : 0,
          nonScript: hasNonScriptIndicators ? -5 : 0 // é«˜æ‡²ç½°
        };
        
        const totalScore = Object.values(score).reduce((sum, val) => sum + val, 0);
        
        console.log('è…³æœ¬æª¢æ¸¬è©•åˆ†:', score);
        console.log('ç¸½åˆ†:', totalScore);
        
        // æ›´éˆæ´»çš„åˆ¤æ–·æ¢ä»¶
        const isScriptContent = totalScore >= 4 && !hasNonScriptIndicators && (hasStructureMarkers || scriptElementCount >= 3);
        
        console.log('æ˜¯å¦ç‚ºè…³æœ¬å…§å®¹:', isScriptContent);
        console.log('=== è…³æœ¬å…§å®¹æª¢æ¸¬çµæŸ ===');
        
        return isScriptContent;
      }
      
      // æ–°å¢ï¼šæ›´ç²¾ç¢ºçš„AIå…§å®¹è§£æå‡½æ•¸
      function parseAIContent(aiText) {
        const sections = {
          title: '',
          script: '',
          visual: '',
          copy: ''
        };
        
        console.log('é–‹å§‹è§£æAIå…§å®¹...');
        console.log('åŸå§‹AIæ–‡æœ¬:', aiText);
        
        // ä½¿ç”¨æ­£å‰‡è¡¨é”å¼ç²¾ç¢ºæå–æ¯å€‹å€å¡Šçš„å…§å®¹
        try {
          // 1. æå–ä¸»é¡Œæ¨™é¡Œ
          const titlePatterns = [
            /ä¸»é¡Œæ¨™é¡Œ[ï¼š:]\s*([^\n]+)/i,
            /ä¸»é¡Œ[ï¼š:]\s*([^\n]+)/i,
            /æ¨™é¡Œ[ï¼š:]\s*([^\n]+)/i,
            /\d+\.\s*ä¸»é¡Œæ¨™é¡Œ[ï¼š:]\s*([^\n]+)/i,
            /\d+\.\s*ä¸»é¡Œ[ï¼š:]\s*([^\n]+)/i,
            /\d+\.\s*æ¨™é¡Œ[ï¼š:]\s*([^\n]+)/i
          ];
          
          for (const pattern of titlePatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.title = cleanMarkdownFormat(match[1].trim());
              console.log('æ‰¾åˆ°ä¸»é¡Œæ¨™é¡Œ:', sections.title);
              break;
            }
          }
          
          // å¦‚æœæ²’æœ‰æ‰¾åˆ°æ˜ç¢ºçš„ä¸»é¡Œæ¨™é¡Œï¼Œå˜—è©¦æå–ç¬¬ä¸€è¡Œä½œç‚ºæ¨™é¡Œ
          if (!sections.title) {
            const lines = aiText.split('\n').filter(line => line.trim().length > 0);
            const firstLine = lines[0];
            if (firstLine && !firstLine.match(/^(Hook|Value|CTA|ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ)/i)) {
              sections.title = cleanMarkdownFormat(firstLine.trim());
              console.log('ä½¿ç”¨ç¬¬ä¸€è¡Œä½œç‚ºä¸»é¡Œæ¨™é¡Œ:', sections.title);
            }
          }
          
          // 2. æå–è…³æœ¬å…§å®¹
          const scriptPatterns = [
            /è…³æœ¬å…§å®¹[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /è…³æœ¬[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /\d+\.\s*è…³æœ¬å…§å®¹[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*ç•«é¢æ„Ÿ|\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /\d+\.\s*è…³æœ¬[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*ç•«é¢æ„Ÿ|\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ|$))/i
          ];
          
          for (const pattern of scriptPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.script = cleanMarkdownFormat(match[1].trim());
              console.log('æ‰¾åˆ°è…³æœ¬å…§å®¹:', sections.script.substring(0, 100) + '...');
              break;
            }
          }
          
          // å¦‚æœæ²’æœ‰æ‰¾åˆ°æ˜ç¢ºçš„è…³æœ¬å…§å®¹æ¨™è¨˜ï¼Œå˜—è©¦æå– Hookã€Valueã€CTA éƒ¨åˆ†
          if (!sections.script) {
            const hookPattern = /Hook\s*\(\d+-\d+ç§’\)[\s\S]*?(?=Value|ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ|$)/i;
            const valuePattern = /Value\s*\d+\s*\(\d+-\d+ç§’\)[\s\S]*?(?=Value|CTA|ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ|$)/i;
            const ctaPattern = /CTA\s*\(\d+-\d+ç§’\)[\s\S]*?(?=ç•«é¢æ„Ÿ|ç™¼ä½ˆæ–‡æ¡ˆ|$)/i;
            
            const hookMatch = aiText.match(hookPattern);
            const valueMatches = aiText.match(new RegExp(valuePattern.source, 'gi'));
            const ctaMatch = aiText.match(ctaPattern);
            
            let scriptContent = '';
            if (hookMatch) scriptContent += hookMatch[0] + '\n\n';
            if (valueMatches) scriptContent += valueMatches.join('\n\n');
            if (ctaMatch) scriptContent += '\n\n' + ctaMatch[0];
            
            if (scriptContent.trim()) {
              sections.script = cleanMarkdownFormat(scriptContent.trim());
              console.log('ä½¿ç”¨ Hook/Value/CTA ä½œç‚ºè…³æœ¬å…§å®¹:', sections.script.substring(0, 100) + '...');
            }
          }
          
          // 3. æå–ç•«é¢æ„Ÿ
          const visualPatterns = [
            /ç•«é¢æ„Ÿ[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /ç•«é¢[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /\d+\.\s*ç•«é¢æ„Ÿ[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ|$))/i,
            /\d+\.\s*ç•«é¢[ï¼š:]\s*([\s\S]*?)(?=\n\s*(?:\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ|$))/i
          ];
          
          for (const pattern of visualPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.visual = cleanMarkdownFormat(match[1].trim());
              console.log('æ‰¾åˆ°ç•«é¢æ„Ÿ:', sections.visual.substring(0, 100) + '...');
              break;
            }
          }
          
          // 4. æå–ç™¼ä½ˆæ–‡æ¡ˆ
          const copyPatterns = [
            /ç™¼ä½ˆæ–‡æ¡ˆ[ï¼š:]\s*([\s\S]*?)$/i,
            /æ–‡æ¡ˆ[ï¼š:]\s*([\s\S]*?)$/i,
            /\d+\.\s*ç™¼ä½ˆæ–‡æ¡ˆ[ï¼š:]\s*([\s\S]*?)$/i,
            /\d+\.\s*æ–‡æ¡ˆ[ï¼š:]\s*([\s\S]*?)$/i
          ];
          
          for (const pattern of copyPatterns) {
            const match = aiText.match(pattern);
            if (match && match[1] && match[1].trim()) {
              sections.copy = cleanMarkdownFormat(match[1].trim());
              console.log('æ‰¾åˆ°ç™¼ä½ˆæ–‡æ¡ˆ:', sections.copy.substring(0, 100) + '...');
              break;
            }
          }
          
          // 5. å¦‚æœæ²’æœ‰æ‰¾åˆ°æ˜ç¢ºçš„æ¨™è¨˜ï¼Œå˜—è©¦æŒ‰æ®µè½åˆ†å‰²
          if (!sections.title && !sections.script && !sections.visual && !sections.copy) {
            console.log('æœªæ‰¾åˆ°æ˜ç¢ºæ¨™è¨˜ï¼Œå˜—è©¦æŒ‰æ®µè½åˆ†å‰²...');
            const paragraphs = aiText.split('\n\n').filter(p => p.trim().length > 0);
            
            if (paragraphs.length >= 1) {
              sections.title = cleanMarkdownFormat(paragraphs[0].trim());
            }
            if (paragraphs.length >= 2) {
              sections.script = cleanMarkdownFormat(paragraphs[1].trim());
            }
            if (paragraphs.length >= 3) {
              sections.visual = cleanMarkdownFormat(paragraphs[2].trim());
            }
            if (paragraphs.length >= 4) {
              sections.copy = cleanMarkdownFormat(paragraphs[3].trim());
            }
          }
          
        } catch (error) {
          console.error('è§£æAIå…§å®¹æ™‚å‡ºéŒ¯:', error);
        }
        
        console.log('æœ€çµ‚è§£æçµæœ:', sections);
        return sections;
      }
    </script>
  </body>
  </html>



